<!DOCTYPE html>
<!--[if lt IE 10]><html class="no-js ie8 oldie" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

  
    itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-offline-url="/"
data-url="/library/view/high-performance-mysql/9780596101718/ch04.html"

data-archive="9780596101718"
data-publishers="O&#x27;Reilly Media, Inc."


  data-htmlfile-name="ch04.html"
  data-epub-title="High Performance MySQL, 2nd Edition"
  


data-federated-auth-enabled="true"

data-env="production"
data-debug="0" ><![endif]-->
<!--[if gt IE 9]><!--><html class="no-js" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

  
    itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-offline-url="/"
data-url="/library/view/high-performance-mysql/9780596101718/ch04.html"

data-archive="9780596101718"
data-publishers="O&#x27;Reilly Media, Inc."


  data-htmlfile-name="ch04.html"
  data-epub-title="High Performance MySQL, 2nd Edition"
  


data-federated-auth-enabled="true"

data-env="production"
data-debug="0" ><!--<![endif]-->
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>4. Query Performance Optimization - High Performance MySQL, 2nd Edition [Book]</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/library/view/static/CACHE/css/output.a4b41127239b.css" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro' rel='stylesheet' type='text/css' />
    <link rel="stylesheet" type="text/css" href="https://cdn.oreillystatic.com/assets/css/2018_font_face.css" />
    

    <meta property="og:title" content="High Performance MySQL, 2nd Edition" />
    <meta itemprop="isPartOf" content="/library/view/high-performance-mysql/9780596101718/" />
    <meta itemprop="name" content="4. Query Performance Optimization" />
    
    <meta property="og:url" itemprop="url" content="https://www.oreilly.com/library/view/high-performance-mysql/9780596101718/ch04.html" />
    <meta property="og:site_name" content="O’Reilly Online Learning" />
    <meta property="og:image" itemprop="thumbnailUrl" content="https://www.oreilly.com/library/cover/9780596101718/" />
    
    <meta property="og:image:secure_url" itemprop="thumbnailUrl" content="https://learning.oreilly.com/library/cover/9780596101718/360h/">
    <meta property="og:description" itemprop="description" name="description" content="Chapter 4. Query Performance Optimization In the previous chapter, we explained how to optimize a schema, which is one of the necessary conditions for high performance. But working with the …  - Selection from High Performance MySQL, 2nd Edition [Book]">
    
    <meta itemprop="inLanguage" content="en" />
    
    <meta itemprop="publisher" content="O&#x27;Reilly Media, Inc." />
    
    <meta property="og:type" content="article" />
    <meta property="og:book:isbn" itemprop="isbn" content="9780596101718" />
    
    <meta property="og:book:author" itemprop="author" content="Jeremy D. Zawodny" />
    <meta property="og:book:author" itemprop="author" content="Derek J. Balling" />
    <meta property="og:book:author" itemprop="author" content="Baron Schwartz" />
    <meta property="og:book:author" itemprop="author" content="Peter Zaitsev" />
    <meta property="og:book:author" itemprop="author" content="Arjen Lentz" />
    <meta property="og:book:author" itemprop="author" content="Vadim Tkachenko" />
    
    <meta property="og:book:tag" itemprop="about" content="Certification" />
    <meta property="og:book:tag" itemprop="about" content="Databases" />
    
    
    
    <meta property="og:image:width" content="400">
    <meta property="og:image:height" content="400">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@OReillyMedia">

<!-- Start Visual Website Optimizer Asynchronous Code -->
<script type='text/javascript'>
var _vwo_code=(function(){
var account_id=291788,
settings_tolerance=2000,
library_tolerance=2500,
use_existing_jquery=false,
/* DO NOT EDIT BELOW THIS LINE */
f=false,d=document;return{use_existing_jquery:function(){return use_existing_jquery;},library_tolerance:function(){return library_tolerance;},finish:function(){if(!f){f=true;var a=d.getElementById('_vis_opt_path_hides');if(a)a.parentNode.removeChild(a);}},finished:function(){return f;},load:function(a){var b=d.createElement('script');b.src=a;b.type='text/javascript';b.innerText;b.onerror=function(){_vwo_code.finish();};d.getElementsByTagName('head')[0].appendChild(b);},init:function(){settings_timer=setTimeout('_vwo_code.finish()',settings_tolerance);var a=d.createElement('style'),b='body{opacity:0 !important;filter:alpha(opacity=0) !important;background:none !important;}',h=d.getElementsByTagName('head')[0];a.setAttribute('id','_vis_opt_path_hides');a.setAttribute('type','text/css');if(a.styleSheet)a.styleSheet.cssText=b;else a.appendChild(d.createTextNode(b));h.appendChild(a);this.load('//dev.visualwebsiteoptimizer.com/j.php?a='+account_id+'&u='+encodeURIComponent(d.URL)+'&r='+Math.random());return settings_timer;}};}());_vwo_settings_timer=_vwo_code.init();
</script>
<!-- End Visual Website Optimizer Asynchronous Code -->

    <link class="t-canonical-link" rel="canonical" href="https://www.oreilly.com/library/view/high-performance-mysql/9780596101718/ch04.html" />

    <link rel="shortcut icon" href="//www.oreilly.com/favicon.ico" type="image/vnd.microsoft.icon" />
    <link rel="apple-touch-icon" href="/library/view/static/images/apple-touch-icon.png" />
    

  
    <style type="text/css" title="ibis-book">
    @charset "utf-8";#sbo-rt-content html,#sbo-rt-content div,#sbo-rt-content div,#sbo-rt-content span,#sbo-rt-content applet,#sbo-rt-content object,#sbo-rt-content iframe,#sbo-rt-content h1,#sbo-rt-content h2,#sbo-rt-content h3,#sbo-rt-content h4,#sbo-rt-content h5,#sbo-rt-content h6,#sbo-rt-content p,#sbo-rt-content blockquote,#sbo-rt-content pre,#sbo-rt-content a,#sbo-rt-content abbr,#sbo-rt-content acronym,#sbo-rt-content address,#sbo-rt-content big,#sbo-rt-content cite,#sbo-rt-content code,#sbo-rt-content del,#sbo-rt-content dfn,#sbo-rt-content em,#sbo-rt-content font,#sbo-rt-content img,#sbo-rt-content ins,#sbo-rt-content kbd,#sbo-rt-content q,#sbo-rt-content s,#sbo-rt-content samp,#sbo-rt-content small,#sbo-rt-content strike,#sbo-rt-content strong,#sbo-rt-content sub,#sbo-rt-content sup,#sbo-rt-content tt,#sbo-rt-content var,#sbo-rt-content b,#sbo-rt-content u,#sbo-rt-content i,#sbo-rt-content center,#sbo-rt-content dl,#sbo-rt-content dt,#sbo-rt-content dd,#sbo-rt-content ol,#sbo-rt-content ul,#sbo-rt-content li,#sbo-rt-content fieldset,#sbo-rt-content form,#sbo-rt-content label,#sbo-rt-content legend,#sbo-rt-content table,#sbo-rt-content caption,#sbo-rt-content tdiv,#sbo-rt-content tfoot,#sbo-rt-content thead,#sbo-rt-content tr,#sbo-rt-content th,#sbo-rt-content td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}@page{margin:5px !important}#sbo-rt-content p{margin:8px 0 0}#sbo-rt-content span.bolditalic{font-weight:bold;font-style:italic}#sbo-rt-content strong,#sbo-rt-content span.bold{font-weight:bold}#sbo-rt-content a.ulink,#sbo-rt-content a.xref,#sbo-rt-content a.email,#sbo-rt-content a.link{text-decoration:none;color:#8e0012}#sbo-rt-content sup{font-size:x-small;vertical-align:super}#sbo-rt-content sub{font-size:smaller;vertical-align:sub}#sbo-rt-content span.lineannotation{font-style:italic;color:red;font-family:serif}#sbo-rt-content span.underline{text-decoration:underline}#sbo-rt-content span.strikethrough{text-decoration:line-through}#sbo-rt-content span.smallcaps{font-variant:small-caps}#sbo-rt-content span.cursor{background:#000;color:#FFF}#sbo-rt-content span.smaller{font-size:75%}#sbo-rt-content .boxedtext,#sbo-rt-content .keycap{border-style:solid;border-width:1px;border-color:#000;padding:1px}#sbo-rt-content span.gray50{color:#7F7F7F;}#sbo-rt-content .gray-background,#sbo-rt-content .reverse-video{background:#2E2E2E;color:#FFF}#sbo-rt-content .light-gray-background{background:#A0A0A0}#sbo-rt-content .preserve-whitespace{white-space:pre-wrap}#sbo-rt-content h1{font-size:1.5em;font-weight:bold;font-family:sans-serif,"DejaVuSans";margin-top:20px !important}#sbo-rt-content h2{font-size:1.3em;font-weight:bold;font-family:sans-serif,"DejaVuSans";color:#8e0012;margin:15px 0 8px 0 !important}#sbo-rt-content h3{font-size:1.1em;font-weight:bold;font-family:sans-serif,"DejaVuSans";margin:10px 0 8px 0 !important}#sbo-rt-content h4{font-size:bold;font-weight:1em;font-family:sans-serif,"DejaVuSans";color:#555;margin:9px 0 !important}#sbo-rt-content h1,#sbo-rt-content h2,#sbo-rt-content h3,#sbo-rt-content h4{-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none;page-break-after:avoid}#sbo-rt-content div.titlepage{page-break-inside:avoid}#sbo-rt-content div.chapter>div.titlepage:first-child h1.title,#sbo-rt-content div.preface>div.titlepage:first-child h1.title,#sbo-rt-content div.appendix>div.titlepage:first-child h1.title{font-size:2em;line-height:1;margin-bottom:15px}#sbo-rt-content img{max-width:95%;margin:0 auto;padding:0}#sbo-rt-content div.figure{margin:10px 0 !important;text-align:center;-webkit-border-radius:5px;border-radius:5px;border:1px solid #000;background-color:transparent;padding:5px !important;page-break-inside:avoid}#sbo-rt-content div.figure p.title,#sbo-rt-content div.informalfigure div.caption{font-size:90%;text-align:center;font-weight:normal;font-style:italic;font-family:serif,"DejaVuSerif";color:#000;padding:5px !important;page-break-before:avoid;page-break-after:avoid}#sbo-rt-content div.informalfigure{text-align:center;padding:5px 0 !important}#sbo-rt-content div.sidebar{margin:10px 0 !important;-webkit-border-radius:5px;border-radius:5px;border:1px solid #000;background-color:transparent;font-size:90%;padding:10px 8px !important;page-break-inside:avoid}#sbo-rt-content div.sidebar p.title{font-weight:bold;font-size:1em;font-family:sans-serif,"DejaVuSans";text-transform:uppercase;letter-spacing:1px;text-align:center;margin:4px 0 6px 0 !important;page-break-inside:avoid}#sbo-rt-content div.sidebar div.figure p.title,#sbo-rt-content div.sidebar div.informalfigure div.caption{font-size:90%;text-align:center;font-weight:normal;font-style:italic;font-family:serif,"DejaVuSerif";color:#000;padding:5px !important;page-break-before:avoid;page-break-after:avoid}#sbo-rt-content div.sidebar ol{margin-left:15px}#sbo-rt-content div.sidebar div.tip,#sbo-rt-content div.sidebar div.note,#sbo-rt-content div.sidebar div.warning,#sbo-rt-content div.sidebar div.caution,#sbo-rt-content div.sidebar div.important{margin:10px 12.5% !important;font-size:90%;padding:10px 5px !important;width:75%}#sbo-rt-content div.sidebar div.tip,#sbo-rt-content div.sidebar div.note{background-color:#f1f6fc;border:none}#sbo-rt-content div.sidebar div.warning,#sbo-rt-content div.sidebar div.caution{background-color:#fce5e8}#sbo-rt-content div.sidebar div.important{background-color:#FBEC5D}#sbo-rt-content div.sidebar div.figure{border:none}#sbo-rt-content pre{white-space:pre-wrap;font-family:"Ubuntu Mono",monospace;margin:10px 0 10px 20px;font-size:85%;display:block;-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none}#sbo-rt-content code{font-family:"Ubuntu Mono",monospace}#sbo-rt-content code strong em,#sbo-rt-content code em strong,#sbo-rt-content pre em strong,#sbo-rt-content pre strong em,#sbo-rt-content strong code em code,#sbo-rt-content em code strong code,#sbo-rt-content span.bolditalic code{font-weight:bold;font-style:italic;font-family:"Ubuntu Mono BoldItal",monospace}#sbo-rt-content code em,#sbo-rt-content em code,#sbo-rt-content pre em,#sbo-rt-content em.replaceable{font-family:"Ubuntu Mono Ital",monospace;font-style:italic}#sbo-rt-content code strong,#sbo-rt-content strong code,#sbo-rt-content pre strong,#sbo-rt-content strong.userinput{font-family:"Ubuntu Mono Bold",monospace;font-weight:bold}#sbo-rt-content div.example{margin:10px 0 15px 0 !important}#sbo-rt-content div.example p.title{font-style:italic;font-weight:normal;font-family:serif,"DejaVuSerif";margin:10px 0 5px 0 !important}#sbo-rt-content li pre.example{padding:10px 0 !important}#sbo-rt-content div.example-contents pre.programlisting,#sbo-rt-content div.example-contents pre.screen{margin:0}#sbo-rt-content span.gray{color:#4C4C4C}#sbo-rt-content div.book div.titlepage h1.title{font-size:3em;font-family:sans-serif,"DejaVuSans";font-weight:bold;margin:50px 0 10px 0 !important;line-height:1;text-align:center}#sbo-rt-content div.book div.titlepage h2.subtitle{text-align:center;color:#000;margin:0 !important;font-style:italic;font-family:serif;font-size:1.5em}#sbo-rt-content div.book div.titlepage div.author h3{font-size:2em;font-family:sans-serif,"DejaVuSans";font-weight:bold;color:#8e0012;margin:50px 0 !important;text-align:center}#sbo-rt-content div.book div.titlepage div.publishername{margin-top:60%;margin-bottom:20px;text-align:center;font-size:1.25em}#sbo-rt-content div.book div.titlepage div.locations p{margin:0;text-align:center}#sbo-rt-content div.book div.titlepage div.locations p.cities{font-size:80%;text-align:center;margin-top:5px}#sbo-rt-content div.preface[title="Dedication"]>div.titlepage h1.title{text-align:center;text-transform:uppercase;font-size:1.5em;margin-top:50px;margin-bottom:50px}#sbo-rt-content div.preface[title="Dedication"] p{font-style:italic;text-align:center}#sbo-rt-content div.colophon h1.title{font-size:1.3em;margin:0 !important;font-family:serif,"DejaVuSerif";font-weight:normal}#sbo-rt-content div.colophon h2.subtitle{margin:0 !important;color:#000;font-family:serif,"DejaVuSerif";font-size:1em;font-weight:normal}#sbo-rt-content div.colophon div.author h3.author{font-size:1.1em;font-family:serif,"DejaVuSerif";margin:10px 0 0 !important;font-weight:normal}#sbo-rt-content div.colophon div.editor h4,#sbo-rt-content div.colophon div.editor h3.editor{color:#000;font-size:.8em;margin:15px 0 0 !important;font-family:serif,"DejaVuSerif";font-weight:normal}#sbo-rt-content div.colophon div.editor h3.editor{font-size:.8em;margin:0 !important;font-family:serif,"DejaVuSerif";font-weight:normal}#sbo-rt-content div.colophon div.publisher{margin-top:10px}#sbo-rt-content div.colophon div.publisher p,#sbo-rt-content div.colophon div.publisher span.publishername{margin:0;font-size:.8em}#sbo-rt-content div.legalnotice p,#sbo-rt-content div.timestamp p{font-size:.8em}#sbo-rt-content div.timestamp p{margin-top:10pt}#sbo-rt-content div.colophon[title="About the Author"] h1.title,#sbo-rt-content div.colophon[title="Colophon"] h1.title{font-size:1.5em;margin:0 !important;font-family:sans-serif,"DejaVuSans";font-weight:bold}#sbo-rt-content section.chapter div.titlepage div.author{margin-bottom:40px}#sbo-rt-content section.chapter div.titlepage div.author div.affiliation{font-style:italic}#sbo-rt-content div.attribution{margin:5px 0 0 50px !important}#sbo-rt-content h3.author span.orgname{display:none}#sbo-rt-content div.epigraph{margin:10px 0 10px 20px !important;page-break-inside:avoid;font-size:90%}#sbo-rt-content blockquote,#sbo-rt-content div.blockquote{margin:10px !important;page-break-inside:avoid;font-size:95%}#sbo-rt-content blockquote p,#sbo-rt-content div.blockquote p{font-style:italic;font-family:serif,"DejaVuSerif"}#sbo-rt-content blockquote div.attribution{margin:5px 0 0 30px !important;text-align:right;width:80%}#sbo-rt-content blockquote div.attribution p{font-style:normal}#sbo-rt-content p.right{text-align:right;margin:0}#sbo-rt-content div.footnote{font-size:90%}#sbo-rt-content div.refnamediv h2,#sbo-rt-content div.refnamediv h3,#sbo-rt-content div.refsynopsisdiv h2{font-size:1.1em;color:#000;margin-top:15px !important;margin-bottom:0 !important}#sbo-rt-content div.refentry div.refsect1 h2{font-size:1.1em;color:#000;margin-top:15px !important;margin-bottom:0 !important}#sbo-rt-content div.refsect2 h3{font-size:1em;color:#000;margin-top:10px !important;margin-bottom:0 !important}#sbo-rt-content div.refnamediv p{margin-left:15px !important}#sbo-rt-content dt{padding-top:10px !important;padding-bottom:0 !important}#sbo-rt-content dd{margin-left:1.5em !important}#sbo-rt-content ol{list-style-type:decimal;margin-top:8px !important;margin-bottom:8px !important;margin-left:20px !important;padding-left:25px !important}#sbo-rt-content ol ol{list-style-type:lower-alpha}#sbo-rt-content ol ol ol{list-style-type:lower-roman}#sbo-rt-content ul{list-style-type:square;margin-top:8px !important;margin-bottom:8px !important;margin-left:5px !important;padding-left:20px !important}#sbo-rt-content ul ul{list-style-type:none;padding-left:0 !important;margin-left:0 !important}#sbo-rt-content ul ul li p:before{content:"— "}#sbo-rt-content ul ul ul li p:before{content:""}#sbo-rt-content ul ul ul{list-style-type:square;margin-left:20px !important;padding-left:30px !important}#sbo-rt-content div.orderedlistalpha{list-style-type:upper-alpha}#sbo-rt-content table.simplelist{margin-left:20px !important;margin-bottom:10px}#sbo-rt-content table.simplelist td{border:none;font-size:90%}#sbo-rt-content table.simplelist tr{border-bottom:none}#sbo-rt-content table.simplelist tr:nth-of-type(even){background-color:transparent}#sbo-rt-content div.calloutlist p:first-child{margin-top:-25px !important}#sbo-rt-content div.calloutlist dd{padding-left:40px !important}#sbo-rt-content div.calloutlist img{padding:0}#sbo-rt-content a.co img{padding:0}#sbo-rt-content div.tip,#sbo-rt-content div.note,#sbo-rt-content div.warning,#sbo-rt-content div.caution,#sbo-rt-content div.important{margin:10px 0 !important;-webkit-border-radius:5px;border-radius:5px;font-size:90%;padding:10px 8px 20px 8px !important;page-break-inside:avoid}#sbo-rt-content div.tip,#sbo-rt-content div.note{border:1px solid #6cafd0;background-color:transparent}#sbo-rt-content div.warning,#sbo-rt-content div.caution{border:1px solid #8e0012;background-color:#fce5e8}#sbo-rt-content div.important{background-color:#FFF68F;border:1px solid #615E3F}#sbo-rt-content div.tip h3,#sbo-rt-content div.note h3,#sbo-rt-content div.warning h3,#sbo-rt-content div.caution h3,#sbo-rt-content div.important h3{font:bold 90%;font-family:sans-serif,"DejaVuSans";text-transform:uppercase;letter-spacing:1px;text-align:center;margin:4px 0 6px !important;color:#000}#sbo-rt-content div.table,#sbo-rt-content table{margin:10px auto !important;max-width:95%;border-collapse:collapse;border-spacing:0}#sbo-rt-content div.table,#sbo-rt-content div.informaltable{page-break-inside:avoid}#sbo-rt-content tr{border-bottom:1px solid #c3c3c3}#sbo-rt-content tr th{border-bottom:#9d9d9d 2px solid !important;border-top:#9d9d9d 2px solid !important}#sbo-rt-content tr:nth-of-type(even){background-color:#f1f6fc}#sbo-rt-content th{font-family:sans-serif,"DejaVuSans";color:#000;font-weight:bold}#sbo-rt-content td,#sbo-rt-content th{padding:.3em;text-align:left;vertical-align:baseline;font-size:80%}#sbo-rt-content div.informaltable table{margin:10px auto !important}#sbo-rt-content div.informaltable table tr{border-bottom:none}#sbo-rt-content div.informaltable table tr:nth-of-type(even){background-color:transparent}#sbo-rt-content div.informaltable td,#sbo-rt-content div.informaltable th{border:#9d9d9d 1px solid}#sbo-rt-content div.table p.title{font-weight:normal;font-style:italic;font-family:serif,"DejaVuSerif";margin:20px 0 0 0 !important;text-align:center;padding:0}#sbo-rt-content table code{font-size:smaller}#sbo-rt-content div.equation p.title{font-weight:normal;font-style:italic;font-family:serif,"DejaVuSerif";margin:20px 0 10px 0 !important;page-break-after:avoid}#sbo-rt-content div.equation-contents{margin-left:20px}#sbo-rt-content span.inlinemediaobject{height:.85em;display:inline-block;margin-bottom:.2em}#sbo-rt-content span.inlinemediaobject img{margin:0;height:.85em}#sbo-rt-content div.informalequation{margin:20px 0 20px 20px;width:75%}#sbo-rt-content div.informalequation img{width:75%}#sbo-rt-content div.index{font-weight:bold}#sbo-rt-content div.index dt{line-height:140%}#sbo-rt-content div.index a.indexterm{color:#8e0012}#sbo-rt-content code.boolean,#sbo-rt-content .navy{color:rgb(0,0,128);}#sbo-rt-content code.character,#sbo-rt-content .olive{color:rgb(128,128,0);}#sbo-rt-content code.comment,#sbo-rt-content .blue{color:rgb(0,0,255);}#sbo-rt-content code.conditional,#sbo-rt-content .limegreen{color:rgb(50,205,50);}#sbo-rt-content code.constant,#sbo-rt-content .darkorange{color:rgb(255,140,0);}#sbo-rt-content code.debug,#sbo-rt-content .darkred{color:rgb(139,0,0);}#sbo-rt-content code.define,#sbo-rt-content .darkgoldenrod,#sbo-rt-content .gold{color:rgb(184,134,11);}#sbo-rt-content code.delimiter,#sbo-rt-content .dimgray{color:rgb(105,105,105);}#sbo-rt-content code.error,#sbo-rt-content .red{color:rgb(255,0,0);}#sbo-rt-content code.exception,#sbo-rt-content .salmon{color:rgb(250,128,11);}#sbo-rt-content code.float,#sbo-rt-content .steelblue{color:rgb(70,130,180);}#sbo-rt-content pre code.function,#sbo-rt-content .green{color:rgb(0,128,0);}#sbo-rt-content code.identifier,#sbo-rt-content .royalblue{color:rgb(65,105,225);}#sbo-rt-content code.ignore,#sbo-rt-content .gray{color:rgb(128,128,128);}#sbo-rt-content code.include,#sbo-rt-content .purple{color:rgb(128,0,128);}#sbo-rt-content code.keyword,#sbo-rt-content .sienna{color:rgb(160,82,45);}#sbo-rt-content code.label,#sbo-rt-content .deeppink{color:rgb(255,20,147);}#sbo-rt-content code.macro,#sbo-rt-content .orangered{color:rgb(255,69,0);}#sbo-rt-content code.number,#sbo-rt-content .brown{color:rgb(165,42,42);}#sbo-rt-content code.operator,#sbo-rt-content .black{color:#000;}#sbo-rt-content code.preCondit,#sbo-rt-content .teal{color:rgb(0,128,128);}#sbo-rt-content code.preProc,#sbo-rt-content .fuschia{color:rgb(255,0,255);}#sbo-rt-content code.repeat,#sbo-rt-content .indigo{color:rgb(75,0,130);}#sbo-rt-content code.special,#sbo-rt-content .saddlebrown{color:rgb(139,69,19);}#sbo-rt-content code.specialchar,#sbo-rt-content .magenta{color:rgb(255,0,255);}#sbo-rt-content code.specialcomment,#sbo-rt-content .seagreen{color:rgb(46,139,87);}#sbo-rt-content code.statement,#sbo-rt-content .forestgreen{color:rgb(34,139,34);}#sbo-rt-content code.storageclass,#sbo-rt-content .plum{color:rgb(221,160,221);}#sbo-rt-content code.string,#sbo-rt-content .darkred{color:rgb(139,0,0);}#sbo-rt-content code.structure,#sbo-rt-content .chocolate{color:rgb(210,106,30);}#sbo-rt-content code.tag,#sbo-rt-content .darkcyan{color:rgb(0,139,139);}#sbo-rt-content code.todo,#sbo-rt-content .black{color:#000;}#sbo-rt-content code.type,#sbo-rt-content .mediumslateblue{color:rgb(123,104,238);}#sbo-rt-content code.typedef,#sbo-rt-content .darkgreen{color:rgb(0,100,0);}#sbo-rt-content code.underlined{text-decoration:underline;}#sbo-rt-content pre code.hll{background-color:#ffc}#sbo-rt-content pre code.c{color:#09F;font-style:italic}#sbo-rt-content pre code.err{color:#A00}#sbo-rt-content pre code.k{color:#069;font-weight:bold}#sbo-rt-content pre code.o{color:#555}#sbo-rt-content pre code.cm{color:#35586C;font-style:italic}#sbo-rt-content pre code.cp{color:#099}#sbo-rt-content pre code.c1{color:#35586C;font-style:italic}#sbo-rt-content pre code.cs{color:#35586C;font-weight:bold;font-style:italic}#sbo-rt-content pre code.gd{background-color:#FCC}#sbo-rt-content pre code.ge{font-style:italic}#sbo-rt-content pre code.gr{color:#F00}#sbo-rt-content pre code.gh{color:#030;font-weight:bold}#sbo-rt-content pre code.gi{background-color:#CFC}#sbo-rt-content pre code.go{color:#000}#sbo-rt-content pre code.gp{color:#009;font-weight:bold}#sbo-rt-content pre code.gs{font-weight:bold}#sbo-rt-content pre code.gu{color:#030;font-weight:bold}#sbo-rt-content pre code.gt{color:#9C6}#sbo-rt-content pre code.kc{color:#069;font-weight:bold}#sbo-rt-content pre code.kd{color:#069;font-weight:bold}#sbo-rt-content pre code.kn{color:#069;font-weight:bold}#sbo-rt-content pre code.kp{color:#069}#sbo-rt-content pre code.kr{color:#069;font-weight:bold}#sbo-rt-content pre code.kt{color:#078;font-weight:bold}#sbo-rt-content pre code.m{color:#F60}#sbo-rt-content pre code.s{color:#C30}#sbo-rt-content pre code.na{color:#309}#sbo-rt-content pre code.nb{color:#366}#sbo-rt-content pre code.nc{color:#0A8;font-weight:bold}#sbo-rt-content pre code.no{color:#360}#sbo-rt-content pre code.nd{color:#99F}#sbo-rt-content pre code.ni{color:#999;font-weight:bold}#sbo-rt-content pre code.ne{color:#C00;font-weight:bold}#sbo-rt-content pre code.nf{color:#C0F}#sbo-rt-content pre code.nl{color:#99F}#sbo-rt-content pre code.nn{color:#0CF;font-weight:bold}#sbo-rt-content pre code.nt{color:#309;font-weight:bold}#sbo-rt-content pre code.nv{color:#033}#sbo-rt-content pre code.ow{color:#000;font-weight:bold}#sbo-rt-content pre code.w{color:#bbb}#sbo-rt-content pre code.mf{color:#F60}#sbo-rt-content pre code.mh{color:#F60}#sbo-rt-content pre code.mi{color:#F60}#sbo-rt-content pre code.mo{color:#F60}#sbo-rt-content pre code.sb{color:#C30}#sbo-rt-content pre code.sc{color:#C30}#sbo-rt-content pre code.sd{color:#C30;font-style:italic}#sbo-rt-content pre code.s2{color:#C30}#sbo-rt-content pre code.se{color:#C30;font-weight:bold}#sbo-rt-content pre code.sh{color:#C30}#sbo-rt-content pre code.si{color:#A00}#sbo-rt-content pre code.sx{color:#C30}#sbo-rt-content pre code.sr{color:#3AA}#sbo-rt-content pre code.s1{color:#C30}#sbo-rt-content pre code.ss{color:#A60}#sbo-rt-content pre code.bp{color:#366}#sbo-rt-content pre code.vc{color:#033}#sbo-rt-content pre code.vg{color:#033}#sbo-rt-content pre code.vi{color:#033}#sbo-rt-content pre code.il{color:#F60}#sbo-rt-content pre code.g{color:#050}#sbo-rt-content pre code.l{color:#C60}#sbo-rt-content pre code.l{color:#F90}#sbo-rt-content pre code.n{color:#008}#sbo-rt-content pre code.nx{color:#008}#sbo-rt-content pre code.py{color:#96F}#sbo-rt-content pre code.p{color:#000}#sbo-rt-content pre code.x{color:#F06}#sbo-rt-content div.blockquote_sampler_toc{width:95%;margin:5px 5px 5px 10px !important}#sbo-rt-content div{font-family:serif,"DejaVuSerif"}
    </style>
  




</head>
<body class="js-preview-content  ">


<div class="skipToMain" id="skipToMain"><a href="#maincontent"><span class="skipToMain-text">Skip to main content</span></a></div>
<header role="banner" class="global">
  <div class="global-nav">
    <div class="content">
      <nav role="navigation" aria-label="site sections">
        <a href="https://www.oreilly.com" class="logo" title="home page" aria-current="page"><img src="https://cdn.oreillystatic.com/images/sitewide-headers/oreilly_logo_mark_red.svg" onerror="this.src='https://cdn.oreillystatic.com/images/sitewide-headers/oreilly_logo_mark_red_@2x.png'; this.onerror=null;" alt="O'Reilly home"></a>

        <button id="mobileNavButton" class="mobileNavButton mobileNavButton--collapse mobileNavButton--3dx" type="button" aria-expanded="false" aria-controls="menuList">
          <span class="mobileNavButton-box">
            <span class="mobileNavButton-inner"></span>
          </span>
        </button>


        <ul id="menuList" class="menuList mobileHidden ">
          <li class="menuList-itemsP1">
            <ul>
              
  <li class="menuList-item menuList-signIn"><a id="chapter-sign-in" class="t-sign-in" href="/member/login/?next=/library/view/high-performance-mysql/9780596101718/ch04.html">Sign In</a></li>


              <li class="menuList-item menuList-tryNow"><a class="menuList-cta" href="https://learning.oreilly.com/p/register/">Try Now</a></li>
            </ul>
          </li>
          <li class="menuList-itemsP2">
            <ul>
              <li class="menuList-item menuList-itemWithSub"><a href="https://www.oreilly.com/online-learning/teams.html">Teams</a>
                <ul class="menuList-subList menuList-itemWithSub">
                  <li class="menuList-subItem menuList-extra"><a href="https://www.oreilly.com/online-learning/business.html">For business</a></li>
                  <li class="menuList-subItem"><a href="https://www.oreilly.com/online-learning/government.html">For government</a></li>
                  <li class="menuList-subItem"><a href="https://www.oreilly.com/online-learning/academic.html">For higher ed</a></li>
                </ul>
              </li>
              <li class="menuList-item"><a href="https://www.oreilly.com/online-learning/individuals.html">Individuals</a></li>
              <li class="menuList-item menuList-itemWithSub"><a href="https://www.oreilly.com/online-learning/features.html">Features</a>
                <ul class="menuList-subList">
                  <li class="menuList-subItem menuList-extra"><a href="https://www.oreilly.com/online-learning/features.html">All features</a></li>
                  <li class="menuList-subItem"><a href="https://www.oreilly.com/online-learning/courses.html">Courses</a></li>
                  <li class="menuList-subItem"><a href="https://www.oreilly.com/online-learning/feature-certification.html">Certifications</a></li>
                  <li class="menuList-subItem"><a href="https://www.oreilly.com/online-learning/intro-interactive-learning.html">Interactive learning</a></li>
                  <li class="menuList-subItem"><a href="https://www.oreilly.com/online-learning/live-events.html">Live events</a></li>
                  <li class="menuList-subItem"><a href="https://www.oreilly.com/online-learning/feature-answers.html">Answers</a></li>
                  <li class="menuList-subItem"><a href="https://www.oreilly.com/online-learning/insights-dashboard.html">Insights reporting</a></li>
                </ul>
              </li>
              <li class="menuList-item"><a href="https://www.oreilly.com/radar/">Blog</a></li>
              <li class="menuList-item" id="nav-forMarketers"><a href="https://www.oreilly.com/content-marketing-solutions.html">Content sponsorship</a></li>
            </ul>
          </li>
        </ul>
      </nav>
    </div>
  </div>


  <div class="global-search">
    <div id="globalSearchContent" class="content">
      <form id="js-search-form" class="t-navigation-form" action="https://learning.oreilly.com/search/">
        
        <script type="application/ld+json">
        {
          "@context": "http://schema.org",
          "@type": "WebSite",
          "url": "https://learning.oreilly.com",
          "potentialAction": {
            "@type": "SearchAction",
            "target": "https://learning.oreilly.com/search/?q={search_term_string}",
            "query-input": "required name=search_term_string"
          }
        }
        </script>
        <input data-search-text-focus= "See everything available through the O’Reilly learning platform and start a free trial. Explore now." data-search-text-idle = "See everything available through the O’Reilly learning platform and start a free trial. Explore now." id="search" type="search" name="query" placeholder="See everything available through the O’Reilly learning platform and start a free trial. Explore now." autocomplete="off" required />
        <input type="submit" value="Search" class="search-submit" />
      </form>
    </div>
  </div>
</header>

    
    
        <div class="sbo-menu-top">
           
            <section class="sbo-toc-container">
                <a href="https://learning.oreilly.com/library/view/high-performance-mysql/9780596101718/" class="sbo-toc-thumb">
                    <span class="sbo-title ss-list">
                        
                            <h1 class="t-title">High Performance MySQL, 2nd Edition by Jeremy D. Zawodny, Derek J. Balling, Baron Schwartz, Peter Zaitsev, Arjen Lentz, Vadim Tkachenko</h1>
                        
                    </span>
                </a>
            </section>
             
        </div>
    


</header>


<section id="trial-overlay">
  <div class="trial-overlay-content">
    <p>Get full access to <em>High Performance MySQL, 2nd Edition</em> and 60K+ other titles, with a free 10-day trial of O'Reilly.</p>

    <p>There are also live events, courses curated by job role, <span class="nowrap">and more.</span></p>

    <div class="controls">
      <a href="https://learning.oreilly.com/p/register/" class="button-primary" data-ga-label="Bottom CTA">Start your free trial</a>
    </div>
    <a class="modal-dismiss" aria-label="modal dismiss"></a>
  </div>
</section>

<main role="main" id="maincontent">
  <div role="document" class="document">
  	
<section id="sbo-reader">
    
    

<div class="sbo-reader-content sbo-sample-reader ">
    
    <div id="sbo-rt-content" class="sbo-rt-content">
    <div id="test-content-id"><div class="chapter" title="Chapter 4. Query Performance Optimization"><div class="titlepage"><div><div><h1 class="title"><a id="query_performance_optimization"></a>Chapter 4. Query Performance Optimization</h1></div></div></div><p>In the previous chapter, we explained how to optimize a schema,
    which is one of the necessary conditions for high performance. But working
    with the schema isn’t enough—you also need to design your queries well. If
    your queries are bad, even the best-designed schema will not perform
    well.</p><p>Query optimization, index optimization, and schema optimization go
    hand in hand. As you gain experience writing queries in MySQL, you will
    come to understand how to design schemas to support efficient queries.
    Similarly, what you learn about optimal schema design will influence the
    kinds of queries you write. This process takes time, so we encourage you
    to refer back to this chapter and the previous one as you learn
    more.</p><p>This chapter begins with general query design considerations—the
    things you should consider first when a query isn’t performing well. We
    then dig much deeper into query optimization and server internals. We show
    you how to find out how MySQL executes a particular query, and you’ll
    learn how to change the query execution plan. Finally, we look at some
    places MySQL doesn’t optimize queries well and explore query optimization
    patterns that help MySQL execute queries more efficiently.</p><p>Our goal is to help you understand deeply how MySQL really executes
    queries, so you can reason about what is efficient or inefficient, exploit
    MySQL’s strengths, and avoid its weaknesses.</p><div class="sect1" title="Slow Query Basics: Optimize Data Access"><div class="titlepage"><div><div><h1 class="title"><a id="slow_query_basics_optimize_data_access"></a>Slow Query Basics: Optimize Data Access</h1></div></div></div><p>The most basic reason a query doesn’t perform well is because it’s
      working with too much data. Some queries just have to sift through a lot
      of data and can’t be helped. That’s unusual, though; most bad queries
      can be changed to access less data. We’ve found it useful to analyze a
      poorly performing query in two steps:<a id="idx-CHP-4-0641" class="indexterm"></a></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Find out whether your <span class="emphasis"><em>application</em></span> is
          retrieving more <a id="idx-CHP-4-0642" class="indexterm"></a>data than you need. That usually means it’s accessing
          too many <a id="idx-CHP-4-0643" class="indexterm"></a>rows, but it might also be accessing too many
          columns.</p></li><li class="listitem"><p>Find out whether the <span class="emphasis"><em>MySQL server</em></span> is
          <a id="idx-CHP-4-0644" class="indexterm"></a>analyzing more rows than it needs.</p></li></ol></div><div class="sect2" title="Are You Asking the Database for Data You Don’t Need?"><div class="titlepage"><div><div><h2 class="title"><a id="are_you_asking_the_database_for_data_you"></a>Are You Asking the Database for Data You Don’t Need?</h2></div></div></div><p>Some queries ask for more data than they need and then throw
        some of it away. This demands extra work of the MySQL server, adds
        network overhead, <sup>[<a id="CHP-4-FNOTE-1" href="#ftn.CHP-4-FNOTE-1" class="footnote">36</a>]</sup> and consumes memory and CPU resources on the application
        server.</p><p>Here are a few typical mistakes:</p><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>Fetching more rows than needed</em></span></span></dt><dd><p>One common mistake is assuming that MySQL provides results
              on demand, rather than calculating and returning the full result
              set. We often see this in applications designed by people
              familiar with other database systems. These developers are used
              to techniques such as issuing a <code class="literal">SELECT</code> statement that returns many
              rows, then fetching the first <em class="replaceable"><code>N</code></em> rows,
              and closing the result set (e.g., fetching the 100 most recent
              articles for a news site when they only need to show 10 of them
              on the front page). They think MySQL will provide them with
              these 10 rows and stop executing the query, but what MySQL
              really does is generate the complete result set. The client
              library then fetches all the data and discards most of it. The
              best solution is to add a <code class="literal">LIMIT</code> clause to the query.</p></dd><dt><span class="term"><span class="emphasis"><em>Fetching all columns from a multitable
            join</em></span></span></dt><dd><p>If you want to retrieve all actors who appear in
              <span class="emphasis"><em>Academy Dinosaur</em></span>, don’t write the query
              this way:</p><a id="I_programlisting4_d1e12565"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM sakila.actor</code></strong>
    -&gt; <strong class="userinput"><code>INNER JOIN sakila.film_actor USING(actor_id)</code></strong>
    -&gt; <strong class="userinput"><code>INNER JOIN sakila.film USING(film_id)</code></strong>
    -&gt; <strong class="userinput"><code>WHERE sakila.film.title = 'Academy Dinosaur';</code></strong></pre><p>That returns all columns from all three tables. Instead,
              write the query as follows:</p><a id="I_programlisting4_d1e12580"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT sakila.actor.* FROM sakila.actor...;</code></strong></pre></dd><dt><span class="term"><span class="emphasis"><em>Fetching all columns</em></span></span></dt><dd><p>You should always be suspicious when you see <code class="literal">SELECT</code> *. Do you really need all
              columns? Probably not. Retrieving all columns can prevent
              optimizations such as covering indexes, as well as adding I/O,
              memory, and CPU overhead for the server.</p><p>Some DBAs ban <code class="literal">SELECT</code> *
              universally because of this fact, and to reduce the risk of
              problems when someone alters the table’s column list.</p><p>Of course, asking for more <a id="idx-CHP-4-0645" class="indexterm"></a>data than you really need is not always bad. In
              many cases we’ve investigated, people tell us the wasteful
              approach simplifies development, as it lets the developer use
              the same bit of code in more than one place. That’s a reasonable
              consideration, as long as you know what it costs in terms of
              performance. It may also be useful to retrieve more data than
              you actually need if you use some type of caching in your
              application, or if you have another benefit in mind. Fetching
              and caching full objects may be preferable to running many
              separate queries that retrieve only parts of the object.</p></dd></dl></div></div><div class="sect2" title="Is MySQL Examining Too Much Data?"><div class="titlepage"><div><div><h2 class="title"><a id="is_mysql_examining_too_much_data"></a>Is MySQL Examining Too Much Data?</h2></div></div></div><p>Once you’re sure your queries <span class="emphasis"><em>retrieve</em></span> only
        the data you need, you can look for queries that
        <span class="emphasis"><em>examine</em></span> too much data while generating results.
        In MySQL, the simplest query cost metrics are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a id="idx-CHP-4-0646" class="indexterm"></a>Execution time</p></li><li class="listitem"><p>Number of <a id="idx-CHP-4-0647" class="indexterm"></a>rows examined</p></li><li class="listitem"><p>Number of <a id="idx-CHP-4-0648" class="indexterm"></a>rows returned</p></li></ul></div><p>None of these metrics is a perfect way to measure query cost,
        but they reflect roughly how much data MySQL must access internally to
        execute a query and translate approximately into how fast the query
        runs. All three metrics are logged in the slow query log, so looking
        at the slow query log is one of the best ways to find queries that
        examine too much data.</p><div class="sect3" title="Execution time"><div class="titlepage"><div><div><h3 class="title"><a id="execution_time"></a>Execution time</h3></div></div></div><p>As discussed in <a class="xref" href="ch02.html" title="Chapter 2. Finding Bottlenecks: Benchmarking and Profiling">Chapter 2</a>, the standard
          slow query logging feature in MySQL 5.0 and earlier has serious
          limitations, including lack of support for fine-grained logging.
          Fortunately, there are patches that let you log and measure slow
          queries with microsecond resolution. These are included in the MySQL
          5.1 server, but you can also patch earlier versions if needed.
          Beware of placing too much emphasis on query execution time. It’s
          nice to look at because it’s an objective metric, but it’s not
          consistent under varying load conditions. Other factors—such as
          storage engine locks (table locks and row locks), high concurrency,
          and hardware—can also have a considerable impact on query execution
          times. This metric is useful for finding queries that impact the
          application’s response time the most or load the server the most,
          but it does not tell you whether the actual execution time is
          reasonable for a query of a given complexity. (Execution time can
          also be both a symptom and a cause of problems, and it’s not always
          obvious which is the case.)</p></div><div class="sect3" title="Rows examined and rows returned"><div class="titlepage"><div><div><h3 class="title"><a id="rows_examined_and_rows_returned"></a>Rows examined and rows returned</h3></div></div></div><p>It’s useful to think about the number of rows examined when
          <a id="idx-CHP-4-0649" class="indexterm"></a>analyzing queries, because you can see how efficiently
          the queries are finding the data you need.</p><p>However, like execution time, it’s not a perfect metric for
          finding bad queries. Not all row accesses are equal. Shorter rows
          are faster to access, and fetching rows from memory is much faster
          than reading them from disk.</p><p>Ideally, the number of <a id="idx-CHP-4-0650" class="indexterm"></a>rows examined would be the same as the number
          returned, but in practice this is rarely possible. For example, when
          constructing rows with joins, multiple rows must be accessed to
          generate each row in the result set. The ratio of rows examined to
          rows returned is usually small—say, between 1:1 and 10:1—but
          sometimes it can be orders of magnitude larger.</p></div><div class="sect3" title="Rows examined and access types"><div class="titlepage"><div><div><h3 class="title"><a id="rows_examined_and_access_types"></a>Rows examined and access types</h3></div></div></div><p>When you’re thinking about the cost of a query, consider the
          cost of finding a single row in a table. MySQL can use several
          <a id="idx-CHP-4-0651" class="indexterm"></a>access methods to find and return a row. Some require
          examining many rows, but others may be able to generate the result
          without examining any.</p><p>The access method(s) appear in the <code class="literal">type</code> column in <code class="literal">EXPLAIN</code>’s output. The access types range
          from a full table scan to index scans, range scans, unique index
          lookups, and constants. Each of these is faster than the one before
          it, because it requires reading less <a id="idx-CHP-4-0652" class="indexterm"></a>data. You don’t need to memorize the access types, but
          you should understand the general concepts of scanning a table,
          scanning an index, range accesses, and single-value accesses.</p><p>If you aren’t getting a good access type, the best way to
          solve the problem is usually by adding an appropriate index. We
          discussed indexing at length in the previous chapter; now you can
          see why indexes are so important to query optimization. Indexes let
          MySQL find rows with a more efficient access type that examines less
          data.</p><p>For example, let’s look at a simple query on the Sakila sample
          database:</p><a id="I_programlisting4_d1e12708"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM sakila.film_actor WHERE film_id = 1;</code></strong></pre><p>This query will return 10 rows, and <code class="literal">EXPLAIN</code> shows that MySQL uses the <code class="literal">ref</code> access type on the <code class="literal">idx_fk_film_id</code> index to execute the
          query:</p><a id="I_programlisting4_d1e12723"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM sakila.film_actor WHERE film_id = 1\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film_actor
         type: ref
possible_keys: idx_fk_film_id
          key: idx_fk_film_id
      key_len: 2
          ref: const
         rows: 10
        Extra:</pre><p><code class="literal">EXPLAIN</code> shows that MySQL
          estimated it needed to <a id="idx-CHP-4-0653" class="indexterm"></a>access only 10 rows. In other words, the query
          optimizer knew the chosen access type could satisfy the query
          efficiently. What would happen if there were no suitable index for
          the query? MySQL would have to use a less optimal access type, as we
          can see if we drop the index and run the query again:</p><a id="I_programlisting4_d1e12740"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE sakila.film_actor DROP FOREIGN KEY fk_film_actor_film;</code></strong>
mysql&gt; <strong class="userinput"><code>ALTER TABLE sakila.film_actor DROP KEY idx_fk_film_id;</code></strong>
mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM sakila.film_actor WHERE film_id = 1\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film_actor
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 5073
        Extra: Using where</pre><p>Predictably, the access type has changed to a full table scan
          (<code class="literal">ALL</code>), and MySQL now estimates
          it’ll have to examine 5,073 rows to satisfy the query. The “Using
          where” in the <code class="literal">Extra</code> column shows
          that the MySQL server is using the <code class="literal">WHERE</code> clause to discard rows after the
          storage engine reads them.</p><p>In general, MySQL can apply a <code class="literal">WHERE</code> clause in three ways, from best to
          worst:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Apply the conditions to the index lookup operation to
              eliminate nonmatching rows. This happens at the storage engine
              layer.</p></li><li class="listitem"><p>Use a covering index (“Using index” in the <code class="literal">Extra</code> column) to avoid row accesses,
              and filter out nonmatching rows after retrieving each result
              from the index. This happens at the server layer, but it doesn’t
              require reading rows from the table.</p></li><li class="listitem"><p>Retrieve rows from the table, then filter nonmatching rows
              (“Using where” in the <code class="literal">Extra</code>
              column). This happens at the server layer and requires the
              server to read rows from the table before it can filter
              them.</p></li></ul></div><p>This example illustrates how important it is to have good
          indexes. Good indexes help your queries get a good access type and
          examine only the rows they need. However, adding an index doesn’t
          always mean that MySQL will access and return the same number of
          rows. For example, here’s a query that uses the <code class="literal">COUNT()</code> aggregate function: <sup>[<a id="CHP-4-FNOTE-2" href="#ftn.CHP-4-FNOTE-2" class="footnote">37</a>]</sup></p><a id="I_programlisting4_d1e12794"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT actor_id, COUNT(*) FROM sakila.film_actor GROUP BY actor_id;</code></strong></pre><p>This query returns only 200 rows, but it needs to read
          thousands of rows to build the result set. An index can’t reduce the
          number of <a id="idx-CHP-4-0654" class="indexterm"></a>rows examined for a query like this one.</p><p>Unfortunately, MySQL does not tell you how many of the
          <a id="idx-CHP-4-0655" class="indexterm"></a>rows it accessed were used to build the result set; it
          tells you only the total number of rows it accessed. Many of these
          rows could be eliminated by a <code class="literal">WHERE</code> clause and end up not contributing
          to the result set. In the previous example, after removing the index
          on <code class="literal">sakila.film_actor</code>, the query
          accessed every row in the table and the <code class="literal">WHERE</code> clause discarded all but 10 of them.
          Only the remaining 10 rows were used to build the result set.
          Understanding how many rows the server accesses and how many it
          really uses requires reasoning about the query.</p><p>If you find that a huge number of rows were examined to
          produce relatively few rows in the result, you can try some more
          sophisticated fixes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Use covering indexes, which store <a id="idx-CHP-4-0656" class="indexterm"></a>data so that the storage engine doesn’t have to
              retrieve the complete rows. (We discussed these in the previous
              chapter.)</p></li><li class="listitem"><p>Change the schema. An example is using summary tables
              (discussed in the previous chapter).</p></li><li class="listitem"><p>Rewrite a complicated query so the MySQL optimizer is able
              to execute it optimally. (We discuss this later in this
              chapter.)</p></li></ul></div></div></div></div><div class="sect1" title="Ways to Restructure Queries"><div class="titlepage"><div><div><h1 class="title"><a id="ways_to_restructure_queries"></a>Ways to Restructure Queries</h1></div></div></div><p>As you optimize problematic queries, your goal should be to find
      alternative ways to get the result you want—but that doesn’t necessarily
      mean getting the same result set back from MySQL. You can sometimes
      transform queries <a id="idx-CHP-4-0657" class="indexterm"></a>into equivalent forms and get better performance. However,
      you should also think about rewriting the query to retrieve different
      results, if that provides an efficiency benefit. You may be able to
      ultimately do the same work by changing the application code as well as
      the query. In this section, we explain techniques that can help you
      restructure a wide range of queries and show you when to use each
      technique.<a id="idx-CHP-4-0658" class="indexterm"></a></p><div class="sect2" title="Complex Queries Versus Many Queries"><div class="titlepage"><div><div><h2 class="title"><a id="complex_queries_versus_many_queries"></a>Complex Queries Versus Many Queries</h2></div></div></div><p>One important query design question is whether it’s preferable
        to break up a complex query into several simpler queries. The
        traditional approach to database design emphasizes doing as much work
        as possible with as few queries as possible. This approach was
        historically better because of the cost of network communication and
        the overhead of the query parsing and optimization stages.</p><p>However, this advice doesn’t apply as much to MySQL, because it
        was designed to handle connecting and disconnecting very efficiently
        and to respond to small and simple queries very quickly. Modern
        networks are also significantly faster than they used to be, reducing
        network latency. MySQL can run more than 50,000 simple queries per
        second on commodity server hardware and over 2,000 queries per second
        from a single correspondent on a Gigabit network, so running multiple
        queries isn’t necessarily such a bad thing.<a id="I_indexterm4_d1e12870" class="indexterm"></a></p><p>Connection response is still slow compared to the number of
        <a id="idx-CHP-4-0659" class="indexterm"></a>rows MySQL can traverse per second internally, though,
        which is counted in millions per second for in-memory data. All else
        being equal, it’s still a good idea to use as few <a id="idx-CHP-4-0660" class="indexterm"></a>queries as possible, but sometimes you can make a query
        more efficient by decomposing it and executing a few simple queries
        instead of one complex one. Don’t be afraid to do this; weigh the
        costs, and go with the strategy that causes less work. We show some
        examples of this technique a little later in the chapter.</p><p>That said, using too many queries is a common mistake in
        application design. For example, some applications perform 10
        single-row queries to retrieve data from a table when they could use a
        single 10-row query. We’ve even seen applications that retrieve each
        column individually, querying each row many times!</p></div><div class="sect2" title="Chopping Up a Query"><div class="titlepage"><div><div><h2 class="title"><a id="chopping_up_a_query"></a>Chopping Up a Query</h2></div></div></div><p>Another way to slice up a query is to divide and conquer,
        keeping it essentially the same but running it in smaller “chunks”
        that affect fewer rows each time.</p><p>Purging old data is a great example. Periodic purge jobs may
        need to remove quite a bit of data, and doing this in one massive
        query could lock a lot of rows for a long time, fill up transaction
        logs, hog resources, and block small queries that shouldn’t be
        interrupted. Chopping up the <code class="literal">DELETE</code>
        statement and using medium-size queries can improve performance
        considerably, and reduce replication lag when a query is replicated.
        For example, instead of running this monolithic query:</p><a id="I_programlisting4_d1e12903"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(),INTERVAL 3 MONTH);</code></strong></pre><p>you could do something like the following pseudocode:</p><a id="I_programlisting4_d1e12909"></a><pre class="programlisting">rows_affected = 0
do {
   rows_affected = do_query(
      "DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(),INTERVAL 3 MONTH)
      LIMIT 10000")
} while rows_affected &gt; 0</pre><p>Deleting 10,000 rows at a time is typically a large enough task
        to make each query efficient, and a short enough task to minimize the
        impact on the server <sup>[<a id="CHP-4-FNOTE-3" href="#ftn.CHP-4-FNOTE-3" class="footnote">38</a>]</sup> (transactional storage engines may benefit from smaller
        transactions). It may also be a good idea to add some sleep time
        between the <code class="literal">DELETE</code> statements to
        spread the load over time and reduce the amount of time locks are
        held.</p></div><div class="sect2" title="Join Decomposition"><div class="titlepage"><div><div><h2 class="title"><a id="join_decomposition"></a>Join Decomposition</h2></div></div></div><p>Many high-performance web sites use <span class="emphasis"><em>join
        decomposition</em></span>. You can decompose a join by running multiple
        single-table queries instead of a multitable join, and then performing
        the join in the application. For example, instead of this single
        query:<a id="idx-CHP-4-0661" class="indexterm"></a><a id="idx-CHP-4-0662" class="indexterm"></a></p><a id="I_programlisting4_d1e12943"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM tag</code></strong>
    -&gt; <strong class="userinput"><code>   JOIN tag_post ON tag_post.tag_id=tag.id</code></strong>
    -&gt; <strong class="userinput"><code>   JOIN post ON tag_post.post_id=post.id</code></strong>
    -&gt; <strong class="userinput"><code>WHERE tag.tag='mysql';</code></strong></pre><p>You might run these queries:</p><a id="I_programlisting4_d1e12958"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM  tag WHERE tag='mysql';</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM  tag_post WHERE tag_id=1234;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT * FROM  post WHERE  post.id in (123,456,567,9098,8904);</code></strong></pre><p>This looks wasteful at first glance, because you’ve increased
        the number of queries without getting anything in return. However,
        such <a id="idx-CHP-4-0663" class="indexterm"></a>restructuring can actually give significant performance
        advantages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Caching can be more efficient. Many applications cache
            “objects” that map directly to tables. In this example, if the
            object with the tag <code class="literal">mysql</code> is
            already cached, the application can skip the first query. If you
            find posts with an id of 123, 567, or 9098 in the cache, you can
            remove them from the <code class="literal">IN()</code> list.
            The query cache might also benefit from this strategy. If only one
            of the tables changes frequently, decomposing a join can reduce
            the number of cache invalidations.</p></li><li class="listitem"><p>For MyISAM tables, performing one query per table uses table
            locks more efficiently: the queries will lock the tables
            individually and relatively briefly, instead of locking them all
            for a longer time.</p></li><li class="listitem"><p>Doing <a id="idx-CHP-4-0664" class="indexterm"></a>joins in the application makes it easier to scale
            the database by placing tables on different servers.</p></li><li class="listitem"><p>The queries themselves can be more efficient. In this
            example, using an <code class="literal">IN()</code> list
            instead of a join lets MySQL sort row IDs and retrieve rows more
            optimally than might be possible with a join. We explain this in
            more detail later.</p></li><li class="listitem"><p>You can reduce redundant row accesses. Doing a join in the
            application means you retrieve each row only once, whereas a join
            in the query is essentially a denormalization that might
            repeatedly access the same data. For the same reason, such
            <a id="idx-CHP-4-0665" class="indexterm"></a>restructuring might also reduce the total network
            traffic and memory usage.</p></li><li class="listitem"><p>To some extent, you can view this technique as manually
            implementing a hash join instead of the nested loops algorithm
            MySQL uses to execute a join. A hash join may be more efficient.
            (We discuss MySQL’s join strategy later in this chapter.)</p></li></ul></div><div class="sidebar"><a id="summary_when_application_joins_may_be_mo"></a><p class="title">ora: Summary: When Application Joins May Be More Efficient</p><p>Doing joins in the application may be more efficient
          when:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You cache and reuse a lot of data from earlier <a id="idx-CHP-4-0666" class="indexterm"></a>queries</p></li><li class="listitem"><p>You use multiple MyISAM tables</p></li><li class="listitem"><p>You distribute data across multiple servers</p></li><li class="listitem"><p>You replace joins with <code class="literal">IN()</code> lists on large tables</p></li><li class="listitem"><p>A join refers to the same table multiple times</p></li></ul></div></div></div></div><div class="sect1" title="Query Execution Basics"><div class="titlepage"><div><div><h1 class="title"><a id="query_execution_basics"></a>Query Execution Basics</h1></div></div></div><p>If you need to get high performance from your MySQL server, one of
      the best ways to invest your time is in learning how MySQL optimizes and
      executes queries. Once you understand this, much of query optimization
      is simply a matter of reasoning from principles, and query optimization
      becomes a very logical process.<a id="idx-CHP-4-0667" class="indexterm"></a></p><div class="tip" title="Tip"><h3 class="title"><a id="tip-12"></a>Tip</h3><p>This discussion assumes you’ve read <a class="xref" href="ch01.html" title="Chapter 1. MySQL Architecture">Chapter 1</a>, which provides a foundation for
        understanding the MySQL query execution engine.</p></div><p><a class="xref" href="ch04.html#execution_path_of_a_query" title="Figure 4-1. Execution path of a query">Figure 4-1</a> shows how MySQL
      generally executes queries.</p><p>Follow along with the illustration to see what happens when you
      send MySQL a query:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The client sends the SQL statement to the server.</p></li><li class="listitem"><p>The server checks the query cache. If there’s a hit, it
          returns the stored result from the cache; otherwise, it passes the
          SQL statement to the next step.</p></li><li class="listitem"><p>The server parses, preprocesses, and optimizes the SQL into a
          query execution plan.</p></li><li class="listitem"><p>The query execution engine executes the plan by making calls
          to the storage engine API.</p></li><li class="listitem"><p>The server sends the result to the client.</p></li></ol></div><p>Each of these steps has some extra complexity, which we discuss in
      the following sections. We also explain which states the query will be
      in during each step. The query optimization process is particularly
      complex and important to understand.</p><div class="figure"><a id="execution_path_of_a_query"></a><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e13091"></a><img src="/api/v2/epubs/9780596101718/files/httpatomoreillycomsourceoreillyimages206456.png" alt="Execution path of a query" width="963" height="1000"></div></div><p class="title">Figure 4-1. Execution path of a query</p></div><div class="sect2" title="The MySQL Client/Server Protocol"><div class="titlepage"><div><div><h2 class="title"><a id="the_mysql_clientserver_protocol"></a>The MySQL Client/Server Protocol</h2></div></div></div><p>Though you don’t need to understand the inner details of MySQL’s
        <a id="idx-CHP-4-0668" class="indexterm"></a>client/server protocol, you do need to understand how it
        works at a high level. The protocol is half-duplex, which means that
        at any given time the MySQL server can be either sending or receiving
        messages, but not both. It also means there is no way to cut a message
        short.</p><p>This protocol makes MySQL communication simple and fast, but it
        limits it in some ways too. For one thing, it means there’s no flow
        control; once one side sends a message, the other side must fetch the
        entire message before responding. It’s like a game of tossing a ball
        back and forth: only one side has the ball at any instant, and you
        can’t toss the ball (send a message) unless you have it.</p><p>The client sends a query to the server as a single packet of
        data. This is why the <code class="literal">max_allowed_packet</code> configuration variable is
        important if you have large queries. <sup>[<a id="CHP-4-FNOTE-4" href="#ftn.CHP-4-FNOTE-4" class="footnote">39</a>]</sup> Once the client sends the query, it doesn’t have the
        ball anymore; it can only wait for results.<a id="idx-CHP-4-0669" class="indexterm"></a></p><p>In contrast, the response from the server usually consists of
        many packets of data. When the server responds, the client has to
        receive the <span class="emphasis"><em>entire</em></span> result set. It cannot simply
        fetch a few rows and then ask the server not to bother sending the
        rest. If the client needs only the first few rows that are returned,
        it either has to wait for all of the server’s packets to arrive and
        then discard the ones it doesn’t need, or disconnect ungracefully.
        Neither is a good idea, which is why appropriate <code class="literal">LIMIT</code> clauses are so important.</p><p>Here’s another way to think about this: when a client fetches
        rows from the server, it thinks it’s <span class="emphasis"><em>pulling</em></span>
        them. But the truth is, the MySQL server is
        <span class="emphasis"><em>pushing</em></span> the rows as it generates them. The client
        is only receiving the pushed rows; there is no way for it to tell the
        server to stop sending rows. The client is “drinking from the fire
        hose,” so to speak. (Yes, that’s a technical term.)</p><p>Most libraries that connect to MySQL let you either fetch the
        whole result set and buffer it in memory, or fetch each row as you
        need it. The default behavior is generally to fetch the whole result
        and buffer it in memory. This is important because until all the rows
        have been fetched, the MySQL server will not release the locks and
        other resources required by the query. The query will be in the
        “Sending data” state (explained in “Query states” on <a class="xref" href="ch04.html#query_states" title="Query states">Query states</a>). When the client library fetches the
        results all at once, it reduces the amount of work the server needs to
        do: the server can finish and clean up the query as quickly as
        possible.</p><p>Most client libraries let you treat the result set as though
        you’re fetching it from the server, although in fact you’re just
        fetching it from the buffer in the library’s memory. This works fine
        most of the time, but it’s not a good idea for huge result sets that
        might take a long time to fetch and use a lot of memory. You can use
        less memory, and start working on the result sooner, if you instruct
        the library not to buffer the result. The downside is that the locks
        and other resources on the server will remain open while your
        application is interacting with the library. <sup>[<a id="CHP-4-FNOTE-5" href="#ftn.CHP-4-FNOTE-5" class="footnote">40</a>]</sup></p><p>Let’s look at an example using PHP. First, here’s how you’ll
        usually query MySQL from PHP:</p><a id="I_programlisting4_d1e13149"></a><pre class="programlisting">&lt;?php
$link   = mysql_connect('localhost', 'user', 'p4ssword');
$result = mysql_query('SELECT * FROM HUGE_TABLE', $link);
while ( $row = mysql_fetch_array($result) ) {
   // Do something with result
}
?&gt;</pre><p>The code seems to indicate that you fetch rows only when you
        need them, in the <code class="literal">while</code> loop.
        However, the code actually fetches the entire result into a buffer
        with the <code class="literal">mysql_query()</code> function
        call. The <code class="literal">while</code> loop simply
        iterates through the buffer. In contrast, the following code doesn’t
        buffer the results, because it uses <code class="literal">mysql_unbuffered_query()</code> instead of <code class="literal">mysql_query()</code>:</p><a id="I_programlisting4_d1e13169"></a><pre class="programlisting">&lt;?php
$link   = mysql_connect('localhost', 'user', 'p4ssword');
$result = mysql_unbuffered_query('SELECT * FROM HUGE_TABLE', $link);
while ( $row = mysql_fetch_array($result) ) {
   // Do something with result
}
?&gt;</pre><p>Programming languages have different ways to override buffering.
        For example, the Perl <code class="literal">DBD::mysql</code>
        driver requires you to specify the C client library’s <code class="literal">mysql_use_result</code> attribute (the default is
        <code class="literal">mysql_buffer_result</code>). Here’s an
        example:</p><a id="I_programlisting4_d1e13182"></a><pre class="programlisting">#!/usr/bin/perl
use DBI;
my $dbh = DBI-&gt;connect('DBI:mysql:;host=localhost', 'user', 'p4ssword');
my $sth = $dbh-&gt;prepare('SELECT * FROM HUGE_TABLE', { mysql_use_result =&gt; 1 });
$sth-&gt;execute();
while ( my $row = $sth-&gt;fetchrow_array() ) {
   # Do something with result
}</pre><p>Notice that the call to <code class="literal">prepare()</code> specified to “use” the result
        instead of “buffering” it. You can also specify this when connecting,
        which will make every statement unbuffered:</p><a id="I_programlisting4_d1e13189"></a><pre class="programlisting">my $dbh = DBI-&gt;connect('DBI:mysql:;mysql_use_result=1', 'user', 'p4ssword');</pre><div class="sect3" title="Query states"><div class="titlepage"><div><div><h3 class="title"><a id="query_states"></a>Query states</h3></div></div></div><p>Each MySQL connection, or <span class="emphasis"><em>thread</em></span>, has a
          state that shows what it is doing at any given time. There are
          several ways to view these <a id="idx-CHP-4-0670" class="indexterm"></a>states, but the easiest is to use the <code class="literal">SHOW FULL PROCESSLIST</code> command (the states
          appear in the <code class="literal">Command</code> column). As
          a query progresses through its lifecycle, its state changes many
          times, and there are dozens of states. The MySQL manual is the
          authoritative source of information for all the states, but we list
          a few here and explain what they mean:<a id="idx-CHP-4-0671" class="indexterm"></a><a id="idx-CHP-4-0672" class="indexterm"></a></p><div class="variablelist"><dl><dt><span class="term"><code class="literal">Sleep</code></span></dt><dd><p>The thread is waiting for a new query from the
                client.<a id="idx-CHP-4-0673" class="indexterm"></a></p></dd><dt><span class="term"><code class="literal">Query</code></span></dt><dd><p>The thread is either executing the query or sending the
                result back to the client.</p></dd><dt><span class="term"><code class="literal">Locked</code></span></dt><dd><p>The thread is waiting for a table lock to be granted at
                the server level. Locks that are implemented by the storage
                engine, such as InnoDB’s row locks, do not cause the thread to
                enter the <code class="literal">Locked</code>
                state.<a id="idx-CHP-4-0674" class="indexterm"></a></p></dd><dt><span class="term"><code class="literal">Analyzing</code>
              <span class="emphasis"><em>and</em></span> <code class="literal">statistics</code></span></dt><dd><p>The thread is checking storage engine statistics and
                optimizing the query.<a id="idx-CHP-4-0675" class="indexterm"></a><a id="idx-CHP-4-0676" class="indexterm"></a></p></dd><dt><span class="term"><code class="literal">Copying to tmp table [on
              disk]</code></span></dt><dd><p>The thread is processing the query and copying results
                to a temporary table, probably for a <code class="literal">GROUP BY</code>, for a filesort, or to
                satisfy a <code class="literal">UNION</code>. If the
                state ends with “on disk,” MySQL is converting an in-memory
                table to an on-disk table.<a id="idx-CHP-4-0677" class="indexterm"></a></p></dd><dt><span class="term"><code class="literal">Sorting result</code></span></dt><dd><p>The thread is sorting a result set.<a id="idx-CHP-4-0678" class="indexterm"></a></p></dd><dt><span class="term"><code class="literal">Sending data</code></span></dt><dd><p>This can mean several things: the thread might be
                sending data between stages of the query, generating the
                result set, or returning the result set to the
                client.<a id="idx-CHP-4-0679" class="indexterm"></a></p><p>It’s helpful to at least know the basic states, so you
                can get a sense of “who has the ball” for the query. On very
                busy servers, you might see an unusual or normally brief
                state, such as <code class="literal">statistics</code>,
                begin to take a significant amount of time. This usually
                indicates that something is wrong.</p></dd></dl></div></div></div><div class="sect2" title="The Query Cache"><div class="titlepage"><div><div><h2 class="title"><a id="the_query_cache"></a>The Query Cache</h2></div></div></div><p>Before even parsing a query, MySQL checks for it in the
        <a id="idx-CHP-4-0680" class="indexterm"></a>query cache, if the cache is enabled. This operation is
        a case sensitive hash lookup. If the query differs from a similar
        query in the cache by even a single byte, it won’t match, and the
        query processing will go to the next stage.<a id="idx-CHP-4-0681" class="indexterm"></a></p><p>If MySQL does find a match in the query cache, it must check
        privileges before returning the cached query. This is possible without
        parsing the query, because MySQL stores table information with the
        cached query. If the privileges are OK, MySQL retrieves the stored
        result from the query cache and sends it to the client, bypassing
        every other stage in query execution. The query is never parsed,
        optimized, or executed.</p><p>You can learn more about the query cache in <a class="xref" href="ch05.html" title="Chapter 5. Advanced MySQL Features">Chapter 5</a>.</p></div><div class="sect2" title="The Query Optimization Process"><div class="titlepage"><div><div><h2 class="title"><a id="the_query_optimization_process"></a>The Query Optimization Process</h2></div></div></div><p>The next step in the query lifecycle turns a SQL query into an
        execution plan for the query execution engine. It has several
        sub-steps: parsing, preprocessing, and optimization. Errors (for
        example, syntax errors) can be raised at any point in the process.
        We’re not trying to document the MySQL internals here, so we’re going
        to take some liberties, such as describing steps separately even
        though they’re often combined wholly or partially for efficiency. Our
        goal is simply to help you understand how MySQL executes queries so
        that you can write better ones.<a id="I_indexterm4_d1e13335" class="indexterm"></a></p><div class="sect3" title="The parser and the preprocessor"><div class="titlepage"><div><div><h3 class="title"><a id="the_parser_and_the_preprocessor"></a>The parser and the preprocessor</h3></div></div></div><p>To begin, MySQL’s <span class="emphasis"><em>parser</em></span> breaks the query
          into tokens and builds a “parse tree” from them. The parser uses
          MySQL’s SQL grammar to interpret and validate the query. For
          instance, it ensures that the tokens in the query are valid and in
          the proper order, and it checks for mistakes such as quoted strings
          that aren’t terminated.<a id="idx-CHP-4-0682" class="indexterm"></a></p><p>The <span class="emphasis"><em>preprocessor</em></span> then checks the
          resulting parse tree for additional semantics that the parser can’t
          resolve. For example, it checks that tables and columns exist, and
          it resolves names and aliases to ensure that column references
          aren’t ambiguous.<a id="idx-CHP-4-0683" class="indexterm"></a></p><p>Next, the preprocessor checks privileges. This is normally
          very fast unless your server has large numbers <a id="idx-CHP-4-0684" class="indexterm"></a>of privileges. (See <a class="xref" href="ch12.html" title="Chapter 12. Security">Chapter 12</a> for
          more on privileges and security.)</p></div><div class="sect3" title="The query optimizer"><div class="titlepage"><div><div><h3 class="title"><a id="the_query_optimizer"></a>The query optimizer</h3></div></div></div><p>The parse tree is now valid and ready for the
          <span class="emphasis"><em>optimizer</em></span> to turn it into a query execution
          plan. A query can often be executed many different ways and produce
          the same result. The optimizer’s job is to find the best
          option.<a id="idx-CHP-4-0685" class="indexterm"></a></p><p>MySQL uses a cost-based optimizer, which means it tries to
          predict the cost of various execution plans and choose the least
          expensive. The unit of cost is a single random four-kilobyte data
          page read. You can see how expensive the optimizer estimated a query
          to be by running the query, then inspecting the <code class="literal">Last_query_cost</code> session variable:</p><a id="I_programlisting4_d1e13391"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT SQL_NO_CACHE COUNT(*) FROM sakila.film_actor;</code></strong>
+----------+
| count(*) |
+----------+
|     5462 |
+----------+
mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'last_query_cost';</code></strong>
+-----------------+-------------+
| Variable_name   | Value       |
+-----------------+-------------+
| Last_query_cost | 1040.599000 |
+-----------------+-------------+</pre><p>This result means that the optimizer estimated it would need
          to do about 1,040 random data page reads to execute the query. It
          bases the estimate on statistics: the number of pages per table or
          index, the <span class="emphasis"><em>cardinality</em></span> (number of distinct
          values) of indexes, the length of rows and keys, and key
          distribution. The optimizer does not include the effects of any type
          of caching in its estimates—it assumes every read will result in a
          disk I/O operation.</p><p>The optimizer may not always choose the best plan, for many
          reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The statistics could be wrong. The server relies on
              storage engines to provide statistics, and they can range from
              exactly correct to wildly inaccurate. For example, the InnoDB
              storage engine doesn’t maintain accurate statistics about the
              number of rows in a table, because of its MVCC
              architecture.</p></li><li class="listitem"><p>The cost metric is not exactly equivalent to the true cost
              of running the query, so even when the statistics are accurate,
              the query may be more or less expensive than MySQL’s
              approximation. A plan that reads more pages might actually be
              cheaper in some cases, such as when the reads are sequential so
              the disk I/O is faster, or when the pages are already cached in
              memory.</p></li><li class="listitem"><p>MySQL’s idea of optimal might not match yours. You
              probably want the fastest execution time, but MySQL doesn’t
              really understand “fast”; it understands “cost,” and as we’ve
              seen, determining cost is not an exact science.</p></li><li class="listitem"><p>MySQL doesn’t consider other queries that are running
              concurrently, which can affect how quickly the query
              runs.</p></li><li class="listitem"><p>MySQL doesn’t always do cost-based optimization. Sometimes
              it just follows the rules, such as “if there’s a full-text
              <code class="literal">MATCH()</code> clause, use a
              <code class="literal">FULLTEXT</code> index if one
              exists.” It will do this even when it would be faster to use a
              different index and a non<code class="literal">-FULLTEXT</code> query with a <code class="literal">WHERE</code> clause.</p></li><li class="listitem"><p>The <a id="idx-CHP-4-0686" class="indexterm"></a>optimizer doesn’t take into account the cost of
              operations not under its control, such as executing stored
              functions or user-defined functions.</p></li><li class="listitem"><p>As we’ll see later, the optimizer can’t always estimate
              every possible execution plan, so it may miss an optimal
              plan.</p></li></ul></div><p>MySQL’s query optimizer is a highly complex piece of software,
          and it uses many optimizations to transform the query into an
          execution plan. There are two basic types of optimizations, which we
          call <span class="emphasis"><em>static</em></span> and <span class="emphasis"><em>dynamic. Static
          optimizations</em></span> can be performed simply by inspecting the
          parse tree. For example, the optimizer can transform the <code class="literal">WHERE</code> clause into an equivalent form by
          applying algebraic rules. <a id="idx-CHP-4-0687" class="indexterm"></a>Static optimizations are independent of values, such
          as the value of a constant in a <code class="literal">WHERE</code> clause. They can be performed once
          and will always be valid, even when the query is reexecuted with
          different values. You can think of these as “compile-time
          optimizations.”<a id="idx-CHP-4-0688" class="indexterm"></a></p><p>In contrast, <span class="emphasis"><em>dynamic optimizations</em></span> are
          based on context and can depend on many factors, such as which value
          is in a <code class="literal">WHERE</code> clause or how many
          rows are in an index. They must be reevaluated each time the query
          is executed. You can think of these as “runtime
          optimizations.”<a id="idx-CHP-4-0689" class="indexterm"></a></p><p>The difference is important in executing prepared statements
          or stored procedures. MySQL can do static optimizations once, but it
          must reevaluate <a id="idx-CHP-4-0690" class="indexterm"></a>dynamic optimizations every time it executes a query.
          MySQL sometimes even reoptimizes the query as it executes it.
          <sup>[<a id="CHP-4-FNOTE-6" href="#ftn.CHP-4-FNOTE-6" class="footnote">41</a>]</sup></p><p>Here are some types of <a id="idx-CHP-4-0691" class="indexterm"></a>optimizations MySQL knows how to do:</p><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>Reordering joins</em></span></span></dt><dd><p>Tables don’t always have to be joined in the order you
                specify in the query. Determining the best join order is an
                important optimization; we explain it in depth in “The join
                <a id="idx-CHP-4-0692" class="indexterm"></a>optimizer” on <a class="xref" href="ch04.html#the_join_optimizer" title="The join optimizer">The join optimizer</a>.</p></dd><dt><span class="term"><span class="emphasis"><em>Converting</em></span> <code class="literal">OUTER JOIN</code><span class="emphasis"><em>s</em></span> to
              <code class="literal">INNER
              JOIN</code><span class="emphasis"><em>s</em></span></span></dt><dd><p>An <code class="literal">OUTER JOIN</code> doesn’t
                necessarily have to be executed as an <code class="literal">OUTER JOIN</code>. Some factors, such as
                the <code class="literal">WHERE</code> clause and table
                schema, can actually cause an <code class="literal">OUTER
                JOIN</code> to be equivalent to an <code class="literal">INNER JOIN</code>. MySQL can recognize this
                and rewrite the join, which makes it eligible for
                reordering.</p></dd><dt><span class="term"><span class="emphasis"><em>Applying algebraic equivalence
              rules</em></span></span></dt><dd><p>MySQL applies algebraic transformations to simplify and
                canonicalize expressions. It can also fold and reduce
                constants, eliminating impossible constraints and constant
                conditions. For example, the term <code class="literal">(5=5 AND a&gt;5)</code> will reduce to just
                <code class="literal">a&gt;5</code>. Similarly, <code class="literal">(a&lt;b AND b=c) AND a=5</code> becomes
                <code class="literal">b&gt;5</code> <code class="literal">AND b=c AND a=5</code>. These rules are
                very useful for writing conditional queries, which we discuss
                later in the chapter.<a id="idx-CHP-4-0693" class="indexterm"></a></p></dd><dt><span class="term"><code class="literal">COUNT()</code>, <code class="literal">MIN()</code>, <span class="emphasis"><em>and</em></span>
              <code class="literal">MAX()</code>
              <span class="emphasis"><em>optimizations</em></span></span></dt><dd><p>Indexes and column nullability can often help MySQL
                optimize away these expressions. For example, to find the
                minimum value of a column that’s leftmost in a B-Tree index,
                MySQL can just request the first row in the index. It can even
                do this in the query optimization stage, and treat the value
                as a constant for the rest of the query. Similarly, to find
                the maximum value in a B-Tree index, the server reads the last
                row. If the server uses this optimization, you’ll see “Select
                tables optimized away” in the <code class="literal">EXPLAIN</code> plan. This literally means
                the optimizer has removed the table from the query plan and
                replaced it with a constant.<a id="idx-CHP-4-0694" class="indexterm"></a><a id="idx-CHP-4-0695" class="indexterm"></a><a id="idx-CHP-4-0696" class="indexterm"></a><a id="idx-CHP-4-0697" class="indexterm"></a></p><p>Likewise, <code class="literal">COUNT(*)</code>
                queries without a <code class="literal">WHERE</code>
                clause can often be optimized away on some storage engines
                (such as MyISAM, which keeps an exact count of rows in the
                table at all times). See “Optimizing COUNT() Queries” on <a class="xref" href="ch04.html#optimizing_specific_types_of_queries" title="Optimizing Specific Types of Queries">Optimizing Specific Types of Queries</a> for
                details.</p></dd><dt><span class="term"><span class="emphasis"><em>Evaluating and reducing constant
              expressions</em></span></span></dt><dd><p>When MySQL detects that an expression can be reduced to
                a constant, it will do so during optimization. For example, a
                user-defined variable can be converted to a constant if it’s
                not changed in the query. Arithmetic expressions are another
                example.<a id="idx-CHP-4-0698" class="indexterm"></a></p><p>Perhaps surprisingly, even something you might consider
                to be a query can be reduced to a constant during the
                optimization phase. One example is a <code class="literal">MIN()</code> on an index. This can even be
                extended to a constant lookup on a primary key or unique
                index. If a <code class="literal">WHERE</code> clause
                applies a constant condition to such an index, the optimizer
                knows MySQL can look up the value at the beginning of the
                query. It will then treat the value as a constant in the rest
                of the query. Here’s an example:</p><a id="I_programlisting4_d1e13657"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT film.film_id, film_actor.actor_id</code></strong>
    -&gt; <strong class="userinput"><code>FROM sakila.film</code></strong>
    -&gt; <strong class="userinput"><code>   INNER JOIN sakila.film_actor USING(film_id)</code></strong>
    -&gt; <strong class="userinput"><code>WHERE film.film_id = 1;</code></strong>
+----+-------------+------------+-------+----------------+-------+------+
| id | select_type | table      | type  | key            | ref   | rows |
+----+-------------+------------+-------+----------------+-------+------+
|  1 | SIMPLE      | film       | const | PRIMARY        | const |    1 |
|  1 | SIMPLE      | film_actor | ref   | idx_fk_film_id | const |   10 |
+----+-------------+------------+-------+----------------+-------+------+</pre></dd></dl></div><p>MySQL executes this query in two steps, which correspond to
          the two rows in the output. The first step is to find the desired
          row in the <code class="literal">film</code> table. MySQL’s
          <a id="idx-CHP-4-0699" class="indexterm"></a>optimizer knows there is only one row, because there’s
          a primary key on the <code class="literal">film_id</code>
          column, and it has already consulted the index during the query
          optimization stage to see how many rows it will find. Because the
          query optimizer has a known quantity (the value in the <code class="literal">WHERE</code> clause) to use in the lookup, this
          table’s <code class="literal">ref</code> type is <code class="literal">const</code>.</p><p>In the second step, MySQL treats the <code class="literal">film_id</code> column from the row found in the
          first step as a known quantity. It can do this because the optimizer
          knows that by the time the query reaches the second step, it will
          know all the values from the first step. Notice that the <code class="literal">film_actor</code> table’s <code class="literal">ref</code> type is <code class="literal">const</code>, just as the <code class="literal">film</code> table’s was.</p><p>Another way you’ll see constant conditions applied is by
          propagating a value’s constant-ness from one place to another if
          there is a <code class="literal">WHERE</code>, <code class="literal">USING</code>, or <code class="literal">ON</code> clause that restricts them to being
          equal. In this example, the optimizer knows that the <code class="literal">USING</code> clause <a id="idx-CHP-4-0700" class="indexterm"></a>forces <code class="literal">film_id</code> to
          have the same value everywhere in the query—it must be equal to the
          constant value given in the <code class="literal">WHERE</code>
          clause.</p><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>Covering indexes</em></span></span></dt><dd><p>MySQL can sometimes use an index to avoid reading row
                data, when the index contains all the columns the query needs.
                We discussed <a id="idx-CHP-4-0701" class="indexterm"></a>covering indexes at length in <a class="xref" href="ch03.html" title="Chapter 3. Schema Optimization and Indexing">Chapter 3</a>.<a id="idx-CHP-4-0702" class="indexterm"></a></p></dd><dt><span class="term"><span class="emphasis"><em>Subquery optimization</em></span></span></dt><dd><p>MySQL can convert some types of <a id="idx-CHP-4-0703" class="indexterm"></a>subqueries into more efficient alternative
                forms, reducing them to index lookups instead of separate
                queries.</p></dd><dt><span class="term"><span class="emphasis"><em>Early termination</em></span></span></dt><dd><p>MySQL can stop processing a query (or a step in a query)
                as soon as it fulfills the query or step. The obvious case is
                a <code class="literal">LIMIT</code> clause, but there
                are several other kinds of early termination. For instance, if
                MySQL detects an impossible condition, it can abort the entire
                query. You can see this in the following example:<a id="idx-CHP-4-0704" class="indexterm"></a></p><a id="I_programlisting4_d1e13788"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT film.film_id FROM sakila.film WHERE film_id = -1;</code></strong>
+----+...+-----------------------------------------------------+
| id |...| Extra                                               |
+----+...+-----------------------------------------------------+
|  1 |...| Impossible WHERE noticed after reading const tables |
+----+...+-----------------------------------------------------+</pre><p>This query stopped during the optimization step, but
                MySQL can also terminate execution sooner in some cases. The
                server can use this optimization when the query execution
                engine recognizes the need to retrieve distinct values, or to
                stop when a value doesn’t exist. For example, the following
                query finds all movies without any actors: <sup>[<a id="CHP-4-FNOTE-7" href="#ftn.CHP-4-FNOTE-7" class="footnote">42</a>]</sup></p><a id="I_programlisting4_d1e13798"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT film.film_id</code></strong>
    -&gt; <strong class="userinput"><code>FROM sakila.film</code></strong>
    -&gt; <strong class="userinput"><code>   LEFT OUTER JOIN sakila.film_actor USING(film_id)</code></strong>
    -&gt; <strong class="userinput"><code><a id="idx-CHP-4-0705" class="indexterm"></a>WHERE film_actor.film_id IS NULL;</code></strong></pre><p>This query works by eliminating any films that have
                actors. Each film might have many actors, but as soon as it
                finds one actor, it stops processing the current film and
                moves to the next one because it knows the <code class="literal">WHERE</code> clause prohibits outputting
                that film. A similar “Distinct/not-exists” optimization can
                apply to certain kinds of <code class="literal">DISTINCT,
                NOT EXISTS()</code>, and <code class="literal">LEFT
                JOIN</code> queries.</p></dd><dt><span class="term"><span class="emphasis"><em>Equality propagation</em></span></span></dt><dd><p>MySQL recognizes when a query holds two columns as
                equal—for example, in a <code class="literal">JOIN</code> condition—and propagates
                <code class="literal">WHERE</code> clauses across
                equivalent columns. For instance, in the following
                query:<a id="idx-CHP-4-0706" class="indexterm"></a></p><a id="I_programlisting4_d1e13843"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT film.film_id</code></strong>
    -&gt; <strong class="userinput"><code>FROM sakila.film</code></strong>
    -&gt; <strong class="userinput"><code>   INNER JOIN sakila.film_actor USING(film_id)</code></strong>
    -&gt; <strong class="userinput"><code>WHERE film.film_id &gt; 500;</code></strong></pre><p>MySQL knows that the <code class="literal">WHERE</code> clause applies not only to the
                <code class="literal">film</code> table but to the
                <code class="literal">film_actor</code> table as well,
                because the <code class="literal">USING</code> clause
                forces the two columns to match.</p><p>If you’re used to another database server that can’t do
                this, you may have been advised to “help the <a id="idx-CHP-4-0707" class="indexterm"></a>optimizer” by manually specifying the <code class="literal">WHERE</code> clause for both tables, like
                this:</p><a id="I_programlisting4_d1e13881"></a><pre class="programlisting">... WHERE film.film_id &gt; 500 AND film_actor.film_id &gt; 500</pre><p>This is unnecessary in MySQL. It just makes your queries
                harder to maintain.</p></dd><dt><span class="term"><code class="literal">IN()</code> <span class="emphasis"><em>list
              comparisons</em></span></span></dt><dd><p>In many database servers, <code class="literal">IN()</code> is just a synonym for multiple
                <code class="literal">OR</code> clauses, because the two
                are logically equivalent. Not so in MySQL, which sorts the
                values in the <code class="literal">IN()</code> list and
                uses a fast binary search to see whether a value is in the
                list. This is O(log <span class="emphasis"><em>n</em></span>) in the size of the
                list, whereas an equivalent series of <code class="literal">OR</code> clauses is
                O(<span class="emphasis"><em>n</em></span>) in the size of the list (i.e., much
                slower for large lists).<a id="idx-CHP-4-0708" class="indexterm"></a></p></dd></dl></div><p>The preceding list is woefully incomplete, as MySQL performs
          more <a id="idx-CHP-4-0709" class="indexterm"></a>optimizations than we could fit into this entire
          chapter, but it should give you an idea of the optimizer’s
          complexity and intelligence. If there’s one thing you should take
          away from this discussion, it’s <span class="emphasis"><em>don’t try to outsmart the
          optimizer</em></span>. You may end up just defeating it, or making
          your queries more complicated and harder to maintain for zero
          benefit. In general, you should let the optimizer do its
          work.<a id="idx-CHP-4-0710" class="indexterm"></a></p><p>Of course, as smart as the optimizer is, there are times when
          it doesn’t give the best result. Sometimes you may know something
          about the data that the optimizer doesn’t, such as a fact that’s
          guaranteed to be true because of application logic. Also, sometimes
          the optimizer doesn’t have the necessary functionality, such as hash
          indexes; at other times, as mentioned earlier, its cost estimates
          may prefer a query plan that turns out to be more expensive than an
          alternative.</p><p>If you know the optimizer isn’t giving a good result, and you
          know why, you can help it. Some of the options are to add a hint to
          the query, rewrite the query, redesign your schema, or add
          indexes.</p></div><div class="sect3" title="Table and index statistics"><div class="titlepage"><div><div><h3 class="title"><a id="table_and_index_statistics"></a>Table and index statistics</h3></div></div></div><p>Recall the various layers in the MySQL server architecture,
          which we illustrated in <a class="xref" href="ch01.html#a_logical_view_of_the_mysql_server_archi" title="Figure 1-1. A logical view of the MySQL server architecture">Figure 1-1</a>. The server
          layer, which contains the query optimizer, doesn’t store statistics
          on data and indexes. That’s a job for the storage engines, because
          each storage engine might keep different kinds of statistics (or
          keep them in a different way). Some engines, such as Archive, don’t
          keep statistics at all!<a id="idx-CHP-4-0711" class="indexterm"></a><a id="idx-CHP-4-0712" class="indexterm"></a></p><p>Because the server doesn’t store statistics, the MySQL query
          optimizer has to ask the engines for statistics on the tables in a
          query. The engines may provide the optimizer with statistics such as
          the number of pages per table or index, the cardinality of tables
          and indexes, the length of rows and keys, and key distribution
          information. The optimizer can use this information to help it
          decide on the best execution plan. We see how these statistics
          influence the optimizer’s choices in later sections.</p></div><div class="sect3" title="MySQL’s join execution strategy"><div class="titlepage"><div><div><h3 class="title"><a id="mysqls_join_execution_strategy"></a>MySQL’s join execution strategy</h3></div></div></div><p>MySQL uses the term “join” more broadly than you might be used
          to. In sum, it considers every query a join—not just every query
          that matches rows from two tables, but every query, period
          (including subqueries, and even a <code class="literal">SELECT</code> against a single table).
          Consequently, it’s very important to understand how MySQL executes
          joins.<a id="idx-CHP-4-0713" class="indexterm"></a><a id="idx-CHP-4-0714" class="indexterm"></a></p><p>Consider the example of a <code class="literal">UNION</code> query. MySQL executes a <code class="literal">UNION</code> as a series of single queries whose
          results are spooled into a temporary table, then read out again.
          Each of the individual queries is a join, in MySQL terminology—and
          so is the act of reading from the resulting temporary table.</p><p>At the moment, MySQL’s join execution strategy is simple: it
          treats every join as a nested-loop join. This means MySQL runs a
          loop to find a row from a table, then runs a nested loop to find a
          matching row in the next table. It continues until it has found a
          matching row in each table in the join. It then builds and returns a
          row from the columns named in the <code class="literal">SELECT</code> list. It tries to build the next
          row by looking for more matching rows in the last table. If it
          doesn’t find any, it backtracks one table and looks <a id="idx-CHP-4-0715" class="indexterm"></a>for more rows there. It keeps backtracking until it
          finds another row in some table, at which point, it looks for a
          matching row in the next table, and so on. <sup>[<a id="CHP-4-FNOTE-8" href="#ftn.CHP-4-FNOTE-8" class="footnote">43</a>]</sup></p><p>This process of finding rows, probing into the next table, and
          then backtracking can be written as nested loops in the execution
          plan—hence the name “nested-loop <a id="idx-CHP-4-0717" class="indexterm"></a>join.” As an example, consider this simple
          query:</p><a id="I_programlisting4_d1e14014"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT tbl1.col1, tbl2.col2</code></strong>
    -&gt; <strong class="userinput"><code>FROM tbl1 INNER JOIN tbl2 USING(col3)</code></strong>
    -&gt; <strong class="userinput"><code>WHERE tbl1.col1 IN(5,6);</code></strong></pre><p>Assuming MySQL decides to join the tables in the order shown
          in the query, the following pseudocode shows how MySQL might execute
          the query:</p><a id="I_programlisting4_d1e14026"></a><pre class="programlisting">outer_iter = iterator over tbl1 where col1 IN(5,6)
outer_row  = outer_iter.next
while outer_row
   inner_iter = iterator over tbl2 where col3 = outer_row.col3
   inner_row  = inner_iter.next
   while inner_row
      output [ outer_row.col1, inner_row.col2 ]
      inner_row = inner_iter.next
   end
   outer_row = outer_iter.next
end</pre><p>This query execution plan applies as easily to a single-table
          query as it does to a many-table query, which is why even a
          single-table query can be considered a join—the single-table join is
          the basic operation from which more complex joins are composed. It
          can support <code class="literal">OUTER JOIN</code>s, too. For
          example, let’s change the example query as follows:</p><a id="I_programlisting4_d1e14033"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT tbl1.col1, tbl2.col2</code></strong>
    -&gt; <strong class="userinput"><code>FROM tbl1 LEFT OUTER JOIN tbl2 USING(col3)</code></strong>
    -&gt; <strong class="userinput"><code>WHERE tbl1.col1 IN(5,6);</code></strong></pre><p>Here’s the corresponding pseudocode, with the changed parts in
          bold:</p><a id="I_programlisting4_d1e14046"></a><pre class="programlisting">outer_iter = iterator over tbl1 where col1 IN(5,6)
outer_row  = outer_iter.next
while outer_row
   inner_iter = iterator over tbl2 where col3 = outer_row.col3
   inner_row  = inner_iter.next
<strong class="userinput"><code>   if inner_row</code></strong>
      while inner_row
         output [ outer_row.col1, inner_row.col2 ]
         inner_row = inner_iter.next
      end
<strong class="userinput"><code>   else</code></strong>
<strong class="userinput"><code>      output [ outer_row.col1, NULL ]</code></strong>
<strong class="userinput"><code>   end</code></strong>
   outer_row = outer_iter.next
end</pre><p>Another way to visualize a query <a id="idx-CHP-4-0718" class="indexterm"></a>execution plan is to use what the <a id="idx-CHP-4-0719" class="indexterm"></a>optimizer folks call a “swim-lane diagram.” <a class="xref" href="ch04.html#swim-lane_diagram_illustrating_retrievin" title="Figure 4-2. Swim-lane diagram illustrating retrieving rows using a join">Figure 4-2</a> contains a
          swim-lane diagram of our initial <code class="literal">INNER
          JOIN</code> query. Read it from left to right and top to
          bottom.<a id="idx-CHP-4-0720" class="indexterm"></a></p><div class="figure"><a id="swim-lane_diagram_illustrating_retrievin"></a><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e14089"></a><img src="/api/v2/epubs/9780596101718/files/httpatomoreillycomsourceoreillyimages206355.png" alt="Swim-lane diagram illustrating retrieving rows using a join" width="1000" height="619"></div></div><p class="title">Figure 4-2. Swim-lane diagram illustrating retrieving rows using a
            join</p></div><p>MySQL executes every kind of query in essentially the same
          way. For example, it handles a subquery in the <code class="literal">FROM</code> clause by executing it first, putting
          the results into a temporary table, <sup>[<a id="CHP-4-FNOTE-9" href="#ftn.CHP-4-FNOTE-9" class="footnote">44</a>]</sup> and then treating that table just like an ordinary
          table (hence the name “derived table”). MySQL executes <code class="literal">UNION</code> queries with temporary tables too,
          and it rewrites all <code class="literal">RIGHT OUTER
          JOIN</code> queries to equivalent <code class="literal">LEFT
          OUTER JOIN</code>. In short, MySQL coerces every kind of query
          into this <a id="idx-CHP-4-0721" class="indexterm"></a>execution plan.</p><p>It’s not possible to execute every legal SQL query this way,
          however. For example, a <code class="literal">FULL OUTER
          JOIN</code> can’t be executed with nested loops and backtracking
          as soon as a table with no matching rows is found, because it might
          begin with a table that has no matching rows. This explains why
          MySQL doesn’t support <code class="literal">FULL OUTER
          JOIN</code>. Still other queries can be executed with nested
          loops, but perform very badly as a result. We look at some of those
          later.<a id="I_indexterm4_d1e14133" class="indexterm"></a></p></div><div class="sect3" title="The execution plan"><div class="titlepage"><div><div><h3 class="title"><a id="the_execution_plan"></a>The execution plan</h3></div></div></div><p>MySQL doesn’t generate byte-code to execute a query, as many
          other database products do. Instead, the query execution plan is
          actually a tree of instructions that the query execution engine
          follows to produce the query results. The final plan contains enough
          <a id="idx-CHP-4-0722" class="indexterm"></a>information to reconstruct the original query. If you
          execute <code class="literal">EXPLAIN EXTENDED</code> on a
          query, followed by <code class="literal">SHOW WARNINGS</code>,
          you’ll see the reconstructed query. <sup>[<a id="CHP-4-FNOTE-10" href="#ftn.CHP-4-FNOTE-10" class="footnote">45</a>]</sup><a id="idx-CHP-4-0723" class="indexterm"></a></p><p>Any multitable query can conceptually be represented as a
          tree. For example, it might be possible to execute a four-table
          <a id="idx-CHP-4-0724" class="indexterm"></a>join as shown in <a class="xref" href="ch04.html#one_way_to_join_multiple_tables" title="Figure 4-3. One way to join multiple tables">Figure 4-3</a>.</p><div class="figure"><a id="one_way_to_join_multiple_tables"></a><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e14178"></a><img src="/api/v2/epubs/9780596101718/files/httpatomoreillycomsourceoreillyimages206434.png" alt="One way to join multiple tables" width="542" height="350"></div></div><p class="title">Figure 4-3. One way to join multiple tables</p></div><p>This is what computer scientists call a <span class="emphasis"><em>balanced
          tree</em></span>. This is not how MySQL executes the query, though.
          As we described in the previous section, MySQL always begins with
          one table and finds matching rows in the next table. Thus, MySQL’s
          query execution plans always take the form of a <span class="emphasis"><em>left-deep
          tree</em></span>, as in <a class="xref" href="ch04.html#how_mysql_joins_multiple_tables" title="Figure 4-4. How MySQL joins multiple tables">Figure 4-4</a>.</p><div class="figure"><a id="how_mysql_joins_multiple_tables"></a><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e14196"></a><img src="/api/v2/epubs/9780596101718/files/httpatomoreillycomsourceoreillyimages206408.png" alt="How MySQL joins multiple tables" width="400" height="483"></div></div><p class="title">Figure 4-4. How MySQL joins multiple tables</p></div></div><div class="sect3" title="The join optimizer"><div class="titlepage"><div><div><h3 class="title"><a id="the_join_optimizer"></a>The join optimizer</h3></div></div></div><p>The most important part of the MySQL query optimizer is the
          <span class="emphasis"><em>join optimizer</em></span>, which decides the best order of
          execution for multitable queries. It is often possible to join the
          tables in several different orders and get the same results. The
          join optimizer estimates the cost for various plans and tries to
          choose the least expensive one that gives the same result.<a id="idx-CHP-4-0725" class="indexterm"></a></p><p>Here’s a query whose tables can be <a id="idx-CHP-4-0726" class="indexterm"></a>joined in different orders without changing the
          results:</p><a id="I_programlisting4_d1e14226"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT film.film_id, film.title, film.release_year, actor.actor_id,</code></strong>
    -&gt; <strong class="userinput"><code>   actor.first_name, actor.last_name</code></strong>
    -&gt; <strong class="userinput"><code>   FROM sakila.film</code></strong>
    -&gt; <strong class="userinput"><code>   INNER JOIN sakila.film_actor USING(film_id)</code></strong>
    -&gt; <strong class="userinput"><code>   INNER JOIN sakila.actor USING(actor_id);</code></strong></pre><p>You can probably think of a few different query plans.
          <a id="idx-CHP-4-0727" class="indexterm"></a>For example, MySQL could begin with the <code class="literal">film</code> table, use the index on <code class="literal">film_id</code> in the <code class="literal">film_actor</code> table to find <code class="literal">actor_id</code> values, and then look up rows in
          the <code class="literal">actor</code> table’s primary key.
          This should be efficient, right? Now let’s use <code class="literal">EXPLAIN</code> to see how MySQL wants to execute
          the query:</p><a id="I_programlisting4_d1e14269"></a><pre class="programlisting">*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: actor
         type: ALL
possible_keys: PRIMARY
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 200
        Extra:
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: film_actor
         type: ref
possible_keys: PRIMARY,idx_fk_film_id
          key: PRIMARY
      key_len: 2
          ref: sakila.actor.actor_id
         rows: 1
        Extra: Using index
*************************** 3. row ***************************
           id: 1
  select_type: SIMPLE
        table: film
         type: eq_ref
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 2
          ref: sakila.film_actor.film_id
         rows: 1
        Extra:</pre><p>This is quite a different plan from the one suggested in the
          previous paragraph. MySQL wants to start with the <code class="literal">actor</code>, table (we know this because it’s
          listed first in the <code class="literal">EXPLAIN</code>
          output) and go in the reverse order. Is this really more efficient?
          Let’s find out. The <code class="literal">STRAIGHT_JOIN</code>
          keyword <a id="idx-CHP-4-0728" class="indexterm"></a>forces the join to proceed in the order specified in
          the query. Here’s the <code class="literal">EXPLAIN</code>
          output for the revised query:</p><a id="I_programlisting4_d1e14293"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT STRAIGHT_JOIN film.film_id...\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film
         type: ALL
possible_keys: PRIMARY
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 951
        Extra:
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: film_actor
         type: ref
possible_keys: PRIMARY,idx_fk_film_id
          key: idx_fk_film_id
      key_len: 2
          ref: sakila.film.film_id
         rows: 1
        Extra: Using index
*************************** 3. row ***************************
           id: 1
  select_type: SIMPLE
        table: actor
         type: eq_ref
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 2
          ref: sakila.film_actor.actor_id
         rows: 1
        Extra:</pre><p>This shows why MySQL wants to reverse the <a id="idx-CHP-4-0729" class="indexterm"></a>join order: doing so will enable it to examine fewer
          rows in the first table. <sup>[<a id="CHP-4-FNOTE-11" href="#ftn.CHP-4-FNOTE-11" class="footnote">46</a>]</sup> In both cases, it will be able to perform fast indexed
          lookups in the second and third tables. The difference is how many
          of these indexed lookups it will have to do:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Placing <code class="literal">film</code> first will
              require about 951 probes into <code class="literal">film_actor</code> and <code class="literal">actor</code>, one for each row in the first
              table.</p></li><li class="listitem"><p>If the server scans the <code class="literal">actor</code> table first, it will have to do
              only 200 index lookups into later tables.</p></li></ul></div><p>In other words, the reversed join order will require less
          backtracking and rereading. To double-check the <a id="idx-CHP-4-0731" class="indexterm"></a>optimizer’s choice, we executed the two query versions
          and looked at the <code class="literal">Last_query_cost</code>
          variable for each. The reordered query had an estimated cost of 241,
          while the estimated cost of forcing the join order was 1,154.</p><p>This is a simple example <a id="idx-CHP-4-0732" class="indexterm"></a>of how MySQL’s <a id="idx-CHP-4-0733" class="indexterm"></a>join <a id="idx-CHP-4-0734" class="indexterm"></a>optimizer can reorder queries to make them less
          expensive to execute. Reordering joins is usually a very effective
          optimization. There are times when it won’t result in an optimal
          plan, and for those times you can use <code class="literal">STRAIGHT_JOIN</code> and write the query in the
          order you think is best—but such times are rare. In most cases, the
          join optimizer will outperform a human.</p><p>The join optimizer tries to produce a query execution plan
          tree with the lowest achievable cost. When possible, it examines all
          potential combinations <a id="idx-CHP-4-0735" class="indexterm"></a>of subtrees, beginning with all one-table
          plans.</p><p>Unfortunately, a join over <span class="emphasis"><em>n</em></span> tables will
          have <span class="emphasis"><em>n</em></span>-factorial combinations of join orders to
          examine. This is called the <span class="emphasis"><em>search space</em></span> of all
          possible query plans, and it grows very quickly—a 10-table join can
          be executed up to 3,628,800 different ways! When the search space
          grows too large, it can take far too long to optimize the query, so
          the server stops doing a full analysis. Instead, it <a id="idx-CHP-4-0736" class="indexterm"></a>resorts to shortcuts such as “greedy” searches when
          the number of tables exceeds the <code class="literal">optimizer_search_depth</code> limit.</p><p>MySQL has many heuristics, accumulated through years of
          research and experimentation, that it uses to speed up the
          optimization stage. This can be beneficial, but it can also mean
          that MySQL may (on rare occasions) miss an optimal plan and choose a
          less optimal one because it’s trying not to examine every possible
          query plan.</p><p>Sometimes queries can’t be reordered, and the join optimizer
          can use this fact to reduce the search space by eliminating choices.
          A <code class="literal">LEFT JOIN</code> is a good example, as
          are correlated subqueries (more about subqueries later). This is
          because the results for one table depend on data retrieved from
          another table. These dependencies help the join optimizer reduce the
          search space by eliminating choices.</p></div><div class="sect3" title="Sort optimizations"><div class="titlepage"><div><div><h3 class="title"><a id="sort_optimizations"></a>Sort optimizations</h3></div></div></div><p>Sorting results can be a costly operation, so you can often
          improve performance by avoiding sorts or by performing them on fewer
          rows.<a id="idx-CHP-4-0737" class="indexterm"></a></p><p>We showed you how to use indexes for sorting in <a class="xref" href="ch03.html" title="Chapter 3. Schema Optimization and Indexing">Chapter 3</a>. When MySQL can’t use
          an index to produce a sorted result, it must sort the rows itself.
          It can do this in memory or on disk, but it always calls this
          process a <span class="emphasis"><em>filesort</em></span>, even if it doesn’t actually
          use a file.</p><p>If the values to be sorted will fit into the sort buffer,
          MySQL can perform the sort entirely in memory with a
          <span class="emphasis"><em>quicksort</em></span>. If MySQL can’t do the sort in
          memory, it performs it on disk by sorting the values in chunks. It
          uses a quicksort to sort each chunk and then merges the sorted chunk
          into the results.</p><p>There are two <a id="idx-CHP-4-0738" class="indexterm"></a>filesort algorithms:</p><div class="variablelist"><dl><dt><span class="term"><span class="emphasis"><em>Two passes (old)</em></span></span></dt><dd><p>Reads row pointers and <code class="literal">ORDER
                BY</code> columns, sorts them, and then scans the sorted
                list and rereads the rows for output.</p><p>The two-pass algorithm can be quite expensive, because
                it reads the rows from the table twice, and the second read
                causes a lot of random I/O. This is especially expensive
                <a id="idx-CHP-4-0739" class="indexterm"></a>for MyISAM, which uses a system call to fetch
                each row (because MyISAM relies on the operating system’s
                cache to hold the data). On the other hand, it stores a
                minimal amount of data during the <a id="idx-CHP-4-0740" class="indexterm"></a>sort, so if the rows to be sorted are completely
                in memory, it can be cheaper to store less data and reread the
                rows to generate the final result.</p></dd><dt><span class="term"><span class="emphasis"><em>Single pass (new)</em></span></span></dt><dd><p>Reads all the columns needed for the query, sorts them
                by the <code class="literal">ORDER BY</code> columns,
                and then scans the sorted list and outputs the specified
                columns.</p><p>This algorithm is available only in MySQL 4.1 and newer.
                It can be much more efficient, especially on large I/O-bound
                datasets, because it avoids reading the rows from the table
                twice and trades random I/O for more sequential I/O. However,
                it has the potential to use a lot more space, because it holds
                all desired columns from each row, not just the columns needed
                to sort the rows. This means fewer tuples will fit into the
                sort buffer, and the filesort will have to perform more sort
                merge passes.</p></dd></dl></div><p>MySQL may use much more temporary storage space for a filesort
          than you’d expect, because it allocates a fixed-size record for each
          tuple it will sort. These records are large enough to hold the
          largest possible tuple, including the full length of each <code class="literal">VARCHAR</code> column. Also, if you’re using
          UTF-8, MySQL allocates three bytes for each character. As a result,
          we’ve seen cases where poorly optimized schemas caused the temporary
          space used for sorting to be many times larger than the entire
          table’s size on disk.</p><p>When sorting a join, MySQL may perform the filesort at two
          stages during the query execution. If the <code class="literal">ORDER BY</code> clause refers only to columns
          from the first table in the join order, MySQL can filesort this
          table and then proceed with the join. If this happens, <code class="literal">EXPLAIN</code> shows “Using filesort” in the
          <code class="literal">Extra</code> column. Otherwise, MySQL
          must store the query’s results into a temporary table and then
          filesort the temporary table after the join finishes. In this case,
          <code class="literal">EXPLAIN</code> shows “Using temporary;
          Using filesort” in the <code class="literal">Extra</code>
          column. If there’s a <code class="literal">LIMIT</code>, it is
          applied after the filesort, so the temporary table and the filesort
          can be very large.</p><p>See “Optimizing for Filesorts” on <a class="xref" href="ch06.html#optimizing_for_filesorts" title="Optimizing for Filesorts">Optimizing for Filesorts</a> for more on how to tune the
          server for filesorts and how to influence which algorithm the server
          uses.</p></div></div><div class="sect2" title="The Query Execution Engine"><div class="titlepage"><div><div><h2 class="title"><a id="the_query_execution_engine"></a>The Query Execution Engine</h2></div></div></div><p>The parsing and optimizing stage outputs a query <a id="idx-CHP-4-0741" class="indexterm"></a>execution plan, which MySQL’s query execution engine
        uses to process the query. The plan is a data structure; it is not
        executable byte-code, which is how many other databases execute
        queries.</p><p>In contrast to the optimization stage, the <a id="idx-CHP-4-0742" class="indexterm"></a>execution stage is usually not all that complex: MySQL
        simply follows the instructions given in the query execution plan.
        Many of the operations in the plan invoke methods implemented by the
        storage engine interface, also known as the <span class="emphasis"><em>handler
        API</em></span>. Each table in the query is represented by an instance
        of a handler. If a table appears three times in the query, for
        example, the server creates three handler instances. Though we glossed
        over this before, MySQL actually creates the handler instances early
        in the optimization stage. The <a id="idx-CHP-4-0743" class="indexterm"></a>optimizer uses them to get information about the tables,
        such as their column names and index statistics.</p><p>The storage engine interface has lots of functionality, but it
        needs only a dozen or so “building-block” operations to execute most
        queries. For example, there’s an operation to read the first row in an
        index, and one to read the next row in an index. This is enough for a
        query that does an index scan. This simplistic execution method makes
        MySQL’s storage engine architecture possible, but it also imposes some
        of the optimizer limitations we’ve discussed.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-13"></a>Tip</h3><p>Not everything is a handler operation. For example, the server
          manages table locks. The handler may implement its own lower-level
          locking, as InnoDB does with row-level locks, but this does not
          replace the server’s own locking implementation. As explained in
          <a class="xref" href="ch01.html" title="Chapter 1. MySQL Architecture">Chapter 1</a>, anything that all storage
          engines share is implemented in the server, such as date and time
          functions, views, and triggers.</p></div><p>To execute the query, the server just repeats the instructions
        until there are no more rows to examine.</p></div><div class="sect2" title="Returning Results to the Client"><div class="titlepage"><div><div><h2 class="title"><a id="returning_results_to_the_client"></a>Returning Results to the Client</h2></div></div></div><p>The final step in executing a query is to reply to the client.
        Even queries that don’t return a result set still reply to the client
        connection with information about the query, such as how many rows it
        affected.<a id="idx-CHP-4-0744" class="indexterm"></a></p><p>If the query is cacheable, MySQL will also place the results
        into the query cache at this stage.</p><p>The server generates and sends results incrementally. Think back
        to the single-sweep multijoin method we mentioned earlier. As soon as
        MySQL processes the last table and generates one row successfully, it
        can and should send that row to the client.</p><p>This has two benefits: it lets the server avoid holding the row
        in memory, and it means the client starts getting the results as soon
        as possible. <sup>[<a id="CHP-4-FNOTE-12" href="#ftn.CHP-4-FNOTE-12" class="footnote">47</a>]</sup></p></div></div><div class="sect1" title="Limitations of the MySQL Query Optimizer"><div class="titlepage"><div><div><h1 class="title"><a id="limitations_of_the_mysql_query_optimizer"></a>Limitations of the MySQL Query Optimizer</h1></div></div></div><p>MySQL’s “everything is a nested-loop join” approach to query
      execution isn’t ideal for optimizing every kind of query. Fortunately,
      there are only a limited number of cases where the MySQL query
      <a id="idx-CHP-4-0745" class="indexterm"></a>optimizer does a poor job, and it’s usually possible to
      rewrite such queries more efficiently.</p><div class="tip" title="Tip"><h3 class="title"><a id="tip-14"></a>Tip</h3><p>The information in this section applies to the MySQL server
        versions to which we have access at the time of this writing—that is,
        up to MySQL 5.1. Some of these <a id="idx-CHP-4-0746" class="indexterm"></a>limitations will probably be eased or removed entirely
        in future versions, and some have already been fixed in versions not
        yet released as GA (generally available). In particular, there are a
        number of subquery optimizations in the MySQL 6 source code, and more
        are in progress.</p></div><div class="sect2" title="Correlated Subqueries"><div class="titlepage"><div><div><h2 class="title"><a id="correlated_subqueries"></a>Correlated Subqueries</h2></div></div></div><p>MySQL sometimes optimizes <a id="idx-CHP-4-0747" class="indexterm"></a>subqueries very badly. The worst offenders are <code class="literal">IN()</code> subqueries in the <code class="literal">WHERE</code> clause. As an example, let’s find all
        films in the Sakila sample database’s <code class="literal">sakila.film</code> table whose casts include the
        actress Penelope Guiness (<code class="literal">actor_id=1</code>). This feels natural to write
        with a subquery, as follows:<a id="idx-CHP-4-0748" class="indexterm"></a></p><a id="I_programlisting4_d1e14623"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM sakila.film</code></strong>
    -&gt; <strong class="userinput"><code>WHERE film_id IN(</code></strong>
    -&gt; <strong class="userinput"><code>   SELECT film_id FROM sakila.film_actor WHERE actor_id = 1);</code></strong></pre><p>It’s tempting to think that MySQL will execute this query from
        the inside out, by finding a list of <code class="literal">actor_id</code> values and substituting them into
        the <code class="literal">IN()</code> list. We said an <code class="literal">IN()</code> list is generally very fast, so you
        might expect the query to be optimized to something like this:</p><a id="I_programlisting4_d1e14644"></a><pre class="programlisting">-- SELECT GROUP_CONCAT(film_id) FROM sakila.film_actor WHERE actor_id = 1;
-- Result: 1,23,25,106,140,166,277,361,438,499,506,509,605,635,749,832,939,970,980
SELECT * FROM sakila.film
WHERE film_id
IN(1,23,25,106,140,166,277,361,438,499,506,509,605,635,749,832,939,970,980);</pre><p>Unfortunately, exactly the opposite happens. MySQL tries to
        “help” the subquery by pushing a correlation into it from the outer
        table, which it thinks will let the subquery find rows more
        efficiently. It rewrites the query as follows:</p><a id="I_programlisting4_d1e14648"></a><pre class="programlisting">SELECT * FROM sakila.film
WHERE <strong class="userinput"><code>EXISTS</code></strong> (
   SELECT * FROM sakila.film_actor WHERE actor_id = 1
<strong class="userinput"><code>   AND film_actor.film_id = film.film_id);</code></strong></pre><p>Now the subquery requires the <code class="literal">film_id</code> from the outer <code class="literal">film</code> table and can’t be executed first.
        <code class="literal">EXPLAIN</code> shows the result as
        <code class="literal">DEPENDENT SUBQUERY</code> (you can use
        <code class="literal">EXPLAIN EXTENDED</code> to see exactly how
        the query is rewritten):</p><a id="I_programlisting4_d1e14672"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM sakila.film ...;</code></strong>
+----+--------------------+------------+--------+------------------------+
| id | select_type        | table      | type   | possible_keys          |
+----+--------------------+------------+--------+------------------------+
|  1 | PRIMARY            | film       | ALL    | NULL                   |
|  2 | DEPENDENT SUBQUERY | film_actor | eq_ref | PRIMARY,idx_fk_film_id |
+----+--------------------+------------+--------+------------------------+</pre><p>According to the <code class="literal">EXPLAIN</code>
        output, MySQL will table-scan the <code class="literal">film</code> table and execute the subquery
        <a id="idx-CHP-4-0749" class="indexterm"></a>for each row it finds. This won’t cause a noticeable
        performance hit on small tables, but if the outer table is very large,
        the performance will be extremely bad. Fortunately, it’s easy to
        rewrite such a query as a <code class="literal">JOIN</code>:</p><a id="I_programlisting4_d1e14696"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT film.* FROM sakila.film</code></strong>
    -&gt; <strong class="userinput"><code>   INNER JOIN sakila.film_actor USING(film_id)</code></strong>
    -&gt; <strong class="userinput"><code>WHERE actor_id = 1;</code></strong></pre><p>Another good optimization is to manually generate the <code class="literal">IN()</code> list by executing the subquery as a
        separate query with <code class="literal">GROUP_CONCAT()</code>.
        Sometimes this can be faster than a <code class="literal">JOIN</code>.</p><p>MySQL has been criticized thoroughly for this particular type
        <a id="idx-CHP-4-0750" class="indexterm"></a>of subquery execution plan. Although it definitely needs
        to be fixed, the criticism often confuses two different issues:
        execution order and caching. Executing the query from the inside out
        is one way to optimize it; caching the inner query’s result is
        another. Rewriting the query yourself lets you take control over both
        aspects. Future versions of MySQL should be able to optimize this type
        of query much better, although this is no easy task. There are very
        bad worst cases for any execution plan, including the inside-out
        execution plan that some people think would be simple to
        optimize.</p><div class="sect3" title="When a correlated subquery is good"><div class="titlepage"><div><div><h3 class="title"><a id="when_a_correlated_subquery_is_good"></a>When a correlated subquery is good</h3></div></div></div><p>MySQL doesn’t always optimize <a id="idx-CHP-4-0751" class="indexterm"></a>correlated subqueries badly. If you hear advice to
          always avoid them, don’t listen! Instead, benchmark and make your
          own decision. Sometimes a correlated subquery is a perfectly
          reasonable, or even optimal, way to get a result. Let’s look at an
          example:<a id="idx-CHP-4-0752" class="indexterm"></a></p><a id="I_programlisting4_d1e14742"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT film_id, language_id FROM sakila.film</code></strong>
    -&gt; <strong class="userinput"><code>WHERE NOT EXISTS(</code></strong>
    -&gt; <strong class="userinput"><code>   SELECT * FROM sakila.film_actor</code></strong>
    -&gt; <strong class="userinput"><code>   WHERE film_actor.film_id = film.film_id</code></strong>
    -&gt; <strong class="userinput"><code>)\G</code></strong>
 *************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: film
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 951
        Extra: Using where
*************************** 2. row ***************************
           id: 2 
  select_type: DEPENDENT SUBQUERY
        table: film_actor
         type: ref 
possible_keys: idx_fk_film_id
          key: idx_fk_film_id
      key_len: 2
          ref: film.film_id
         rows: 2
        Extra: Using where; Using index</pre><p>The standard advice <a id="idx-CHP-4-0753" class="indexterm"></a>for this query is to write it as a <code class="literal">LEFT OUTER JOIN</code> instead <a id="idx-CHP-4-0754" class="indexterm"></a>of using a subquery. In theory, MySQL’s execution plan
          will be essentially the same either way. Let’s see:</p><a id="I_programlisting4_d1e14780"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT film.film_id, film.language_id</code></strong>
    -&gt; <strong class="userinput"><code>FROM sakila.film</code></strong>
    -&gt; <strong class="userinput"><code>   LEFT OUTER JOIN sakila.film_actor USING(film_id)</code></strong>
    -&gt; <strong class="userinput"><code>WHERE film_actor.film_id IS NULL\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 951
        Extra:
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: film_actor
         type: ref
possible_keys: idx_fk_film_id
          key: idx_fk_film_id
      key_len: 2
          ref: sakila.film.film_id
         rows: 2
        Extra: Using where; Using index; <strong class="userinput"><code>Not exists</code></strong></pre><p>The plans are nearly identical, but there are some
          differences:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">SELECT</code> type against
              <code class="literal">film_actor</code> is <code class="literal">DEPENDENT SUBQUERY</code> in one query and
              <code class="literal">SIMPLE</code> in the other. This
              difference simply reflects the syntax, because the first query
              uses a subquery and the second doesn’t. It doesn’t make much
              difference in terms of handler operations.</p></li><li class="listitem"><p>The second query doesn’t say “Using where” in the <code class="literal">Extra</code> column for the <code class="literal">film</code> table. That doesn’t matter,
              though: the second query’s <code class="literal">USING</code> clause is the same thing as a
              <code class="literal">WHERE</code> clause anyway.</p></li><li class="listitem"><p>The second query says “Not exists” in the <code class="literal">film_actor</code> table’s <code class="literal">Extra</code> column. This is an example
              <a id="idx-CHP-4-0755" class="indexterm"></a>of the early-termination algorithm we mentioned
              earlier in this chapter. It means MySQL is using a not-exists
              optimization to avoid reading more than one row in the <code class="literal">film_actor</code> table’s <code class="literal">idx_fk_film_id</code> index. This is
              equivalent to a <code class="literal">NOT</code> <code class="literal">EXISTS()</code> <a id="idx-CHP-4-0756" class="indexterm"></a>correlated subquery, because it stops processing
              the current row as soon as it finds a match.</p></li></ul></div><p>So, in theory, MySQL will execute the queries almost
          identically. In reality, benchmarking is the only way to tell which
          approach is really faster. We benchmarked both queries on our
          standard setup. The results are shown in <a class="xref" href="ch04.html#not_exists_versus_left_outer_join" title="Table 4-1. NOT EXISTS versus LEFT OUTER JOIN">Table 4-1</a>.</p><div class="table"><a id="not_exists_versus_left_outer_join"></a><p class="title">Table 4-1. NOT EXISTS versus LEFT OUTER JOIN</p><div class="table-contents"><table summary="NOT EXISTS versus LEFT OUTER JOIN" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Query</p></th><th style="border-bottom: 0.5pt solid ; "><p>Result in queries per second
                  (QPS)</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">NOT EXISTS</code>
                  subquery</p></td><td style="border-bottom: 0.5pt solid ; "><p>360 QPS</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">LEFT OUTER
                  JOIN</code></p></td><td style=""><p>425 QPS</p></td></tr></tbody></table></div></div><p>Our benchmark found that the subquery is quite a bit
          slower!</p><p>However, this isn’t always the case. Sometimes a subquery can
          be faster. <a id="idx-CHP-4-0757" class="indexterm"></a>For example, it can work well when you just want to
          see rows from one table that match rows in another table. Although
          that sounds like it describes a join perfectly, it’s not always the
          same thing. The following join, which is designed to find every film
          that has an actor, will return duplicates because some films have
          multiple actors:</p><a id="I_programlisting4_d1e14912"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT film.film_id FROM sakila.film</code></strong>
    -&gt; <strong class="userinput"><code>   INNER JOIN sakila.film_actor USING(film_id);</code></strong></pre><p>We need to use <code class="literal">DISTINCT</code> or
          <code class="literal">GROUP BY</code> to eliminate the
          duplicates:</p><a id="I_programlisting4_d1e14927"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT DISTINCT film.film_id FROM sakila.film</code></strong>
    -&gt; <strong class="userinput"><code>   INNER JOIN sakila.film_actor USING(film_id);</code></strong></pre><p>But what are we really trying to express with this query, and
          is it obvious from the SQL? The <code class="literal">EXISTS</code> operator expresses the logical
          concept of “has a match” without producing duplicated rows and
          avoids a <code class="literal">GROUP BY</code> or <code class="literal">DISTINCT</code> operation, which might require a
          temporary table. Here’s the query written as a subquery instead of a
          join:</p><a id="I_programlisting4_d1e14945"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT film_id FROM sakila.film</code></strong>
    -&gt; <strong class="userinput"><code>   WHERE EXISTS(SELECT * FROM sakila.film_actor</code></strong>
    -&gt; <strong class="userinput"><code>   WHERE film.film_id = film_actor.film_id);</code></strong></pre><p>Again, we benchmarked to see which strategy was faster. The
          results are shown in <a class="xref" href="ch04.html#exists_versus_inner_join" title="Table 4-2. EXISTS versus INNER JOIN">Table 4-2</a>.</p><div class="table"><a id="exists_versus_inner_join"></a><p class="title">Table 4-2. EXISTS versus INNER JOIN</p><div class="table-contents"><table summary="EXISTS versus INNER JOIN" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Query</p></th><th style="border-bottom: 0.5pt solid ; "><p>Result in queries per second
                  (QPS)</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">INNER
                  JOIN</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>185 QPS</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">EXISTS</code>
                  subquery</p></td><td style=""><p>325 QPS</p></td></tr></tbody></table></div></div><p>In this example, the subquery <a id="idx-CHP-4-0758" class="indexterm"></a>performs much faster than the join.</p><p>We showed this lengthy example to illustrate two points: you
          should not heed categorical advice about <a id="idx-CHP-4-0759" class="indexterm"></a>subqueries, and you should use benchmarks to prove
          your assumptions about query plans and execution speed.</p></div><div class="sect3" title="UNION limitations"><div class="titlepage"><div><div><h3 class="title"><a id="union_limitations"></a>UNION limitations</h3></div></div></div><p>MySQL sometimes can’t “push down” conditions from the outside
          of a <code class="literal">UNION</code> to the inside, where
          they could be used to limit results or enable additional
          optimizations.<a id="idx-CHP-4-0760" class="indexterm"></a><a id="idx-CHP-4-0761" class="indexterm"></a></p><p>If you think any of the individual queries inside a <code class="literal">UNION</code> would benefit from a <code class="literal">LIMIT</code>, or if you know they’ll be subject
          to an <code class="literal">ORDER BY</code> clause once
          combined with other queries, you need to put those clauses inside
          each part of the <code class="literal">UNION</code>. For
          example, if you <code class="literal">UNION</code> together
          two huge tables and <code class="literal">LIMIT</code> the
          result to the first 20 rows, MySQL will store both huge tables into
          a temporary table and then retrieve just 20 rows from it. You can
          avoid this by placing <code class="literal">LIMIT 20</code> on
          each query inside the <code class="literal">UNION</code>.</p></div><div class="sect3" title="Index merge optimizations"><div class="titlepage"><div><div><h3 class="title"><a id="index_merge_optimizations"></a>Index merge optimizations</h3></div></div></div><p><a id="idx-CHP-4-0762" class="indexterm"></a>Index merge algorithms, introduced in MySQL 5.0, let
          MySQL use more than one index per table in a query. Earlier versions
          of MySQL could use only a single index, so when no single index was
          good enough to help with all the restrictions in the <code class="literal">WHERE</code> clause, MySQL often chose a table
          scan. For example, the <code class="literal">film_actor</code>
          table has an index on <code class="literal">film_id</code> and
          an index on <code class="literal">actor_id</code>, but neither
          is a good choice for both <code class="literal">WHERE</code>
          conditions in this query:</p><a id="I_programlisting4_d1e15075"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT film_id, actor_id FROM sakila.film_actor</code></strong>
    -&gt; <strong class="userinput"><code>WHERE actor_id = 1 OR film_id = 1;</code></strong></pre><p>In older MySQL versions, that query would produce a table scan
          unless you wrote it as the <code class="literal">UNION</code>
          of two queries:</p><a id="I_programlisting4_d1e15087"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id = 1</code></strong>
    -&gt; <strong class="userinput"><code>UNION ALL</code></strong>
    -&gt; <strong class="userinput"><code>SELECT film_id, actor_id FROM sakila.film_actor WHERE film_id = 1</code></strong>
    -&gt; <strong class="userinput"><code>   AND actor_id &lt;&gt; 1;</code></strong></pre><p>In MySQL 5.0 and newer, however, the query can use both
          indexes, scanning them simultaneously and merging the results. There
          are three variations on the algorithm: union for <code class="literal">OR</code> conditions, intersection for <code class="literal">AND</code> conditions, and unions of
          intersections for combinations of the two. The following query uses
          a union of two index scans, as you can see by examining the <code class="literal">Extra</code> column:</p><a id="I_programlisting4_d1e15111"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT film_id, actor_id FROM sakila.film_actor</code></strong>
    -&gt; <strong class="userinput"><code>WHERE actor_id = 1 OR film_id = 1\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film_actor
         type: index_merge
possible_keys: PRIMARY,idx_fk_film_id
          key: PRIMARY,idx_fk_film_id
      key_len: 2,2
          ref: NULL
         rows: 29
        Extra: <strong class="userinput"><code>Using union(PRIMARY,idx_fk_film_id);</code></strong> Using where</pre><p>MySQL can use this technique on complex <code class="literal">WHERE</code> clauses, so you may see nested
          operations in the <code class="literal">Extra</code> column
          for some queries. This <a id="idx-CHP-4-0763" class="indexterm"></a>often works very well, but sometimes the algorithm’s
          buffering, sorting, and merging operations use lots of CPU and
          memory resources. This is especially true if not all of the indexes
          are very selective, so the parallel scans return lots of rows to the
          merge operation. Recall that the <a id="idx-CHP-4-0764" class="indexterm"></a>optimizer doesn’t account for this cost—it optimizes
          just the number of random page reads. This can make it “underprice”
          the query, which might in fact run more slowly than a plain table
          scan. The intensive memory and CPU usage also tends to impact
          concurrent queries, but you won’t see this effect when you run the
          query in isolation. This is another reason to design realistic
          benchmarks.</p><p>If your queries run more slowly because of this optimizer
          limitation, you can work around it by disabling some indexes with
          <code class="literal">IGNORE INDEX</code>, or just fall back
          to the old <code class="literal">UNION</code> tactic.</p></div><div class="sect3" title="Equality propagation"><div class="titlepage"><div><div><h3 class="title"><a id="equality_propagation"></a>Equality propagation</h3></div></div></div><p>Equality propagation can have unexpected costs sometimes. For
          example, consider a huge <code class="literal">IN()</code>
          list on a column the optimizer knows will be equal to some columns
          on other tables, due to a <code class="literal">WHERE,
          ON</code>, or <code class="literal">USING</code> clause
          that sets the columns equal to each other.<a id="idx-CHP-4-0765" class="indexterm"></a></p><p>The optimizer will “share” the list by copying it to the
          corresponding columns in all related tables. This is normally
          helpful, because it gives the query optimizer and execution engine
          more options for where to actually execute the <code class="literal">IN()</code> check. But when the list is very
          large, it can result in slower optimization and execution. There’s
          no built-in workaround for this problem at the time of this
          writing—you’ll have to change the source code if it’s a problem for
          you. (It’s not a problem for most people.)</p></div><div class="sect3" title="Parallel execution"><div class="titlepage"><div><div><h3 class="title"><a id="parallel_execution"></a>Parallel execution</h3></div></div></div><p>MySQL can’t execute a single query in parallel on many CPUs.
          This is a feature offered by some other database servers, but not
          MySQL. We mention it so that you won’t spend a lot of time trying to
          figure out how to get parallel query execution on MySQL!<a id="idx-CHP-4-0766" class="indexterm"></a></p></div><div class="sect3" title="Hash joins"><div class="titlepage"><div><div><h3 class="title"><a id="hash_joins"></a>Hash joins</h3></div></div></div><p>MySQL can’t do true hash joins at the time of this
          writing—everything is a nested-loop join. However, you can emulate
          hash joins using hash indexes. If you aren’t using the Memory
          storage engine, you’ll have to emulate the hash indexes, too. We
          showed you how to do this in “Building your own hash indexes” on
          <a class="xref" href="ch03.html#hash_indexes" title="Hash indexes">Hash indexes</a>.<a id="idx-CHP-4-0767" class="indexterm"></a></p></div><div class="sect3" title="Loose index scans"><div class="titlepage"><div><div><h3 class="title"><a id="loose_index_scans"></a>Loose index scans</h3></div></div></div><p>MySQL has historically been unable to do <a id="idx-CHP-4-0768" class="indexterm"></a>loose <a id="idx-CHP-4-0769" class="indexterm"></a>index scans, which scan noncontiguous ranges
          <a id="idx-CHP-4-0770" class="indexterm"></a>of an index. MySQL’s index scans generally require a
          defined start point and a defined end point in the index, even if
          only a few noncontiguous rows in the middle are really desired
          <a id="idx-CHP-4-0771" class="indexterm"></a>for the query. MySQL will scan the entire range of
          rows within these end points.</p><p>An example will help clarify this. Suppose we have a table
          with an index on columns <code class="literal">(a, b),</code>
          and we want to run the following query:</p><a id="I_programlisting4_d1e15228"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT ... FROM tbl WHERE b BETWEEN 2 AND 3;</code></strong></pre><p>Because the index begins with column <code class="literal">a</code>, but the query’s <code class="literal">WHERE</code> clause doesn’t specify column
          <code class="literal">a</code>, MySQL will do a table scan and
          eliminate the nonmatching rows with a <code class="literal">WHERE</code> clause, as shown in <a class="xref" href="ch04.html#mysql_scans_the_entire_table_to_find_row" title="Figure 4-5. MySQL scans the entire table to find rows">Figure 4-5</a>.</p><div class="figure"><a id="mysql_scans_the_entire_table_to_find_row"></a><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e15251"></a><img src="/api/v2/epubs/9780596101718/files/httpatomoreillycomsourceoreillyimages206446.png" alt="MySQL scans the entire table to find rows" width="721" height="875"></div></div><p class="title">Figure 4-5. MySQL scans the entire table to find rows</p></div><p>It’s easy to see that there’s a faster way to execute this
          query. The index’s structure (but not MySQL’s storage engine API)
          lets you seek to the beginning of each range of values, scan until
          the end of the range, and then backtrack and jump ahead to the start
          of the next range. <a class="xref" href="ch04.html#a_loose_index_scan_which_mysql_cannot_cu" title="Figure 4-6. A loose index scan, which MySQL cannot currently do, would be more efficient">Figure 4-6</a> shows what
          that strategy would look like if MySQL were able to do it.</p><p>Notice the absence of a <code class="literal">WHERE</code> clause, which isn’t needed because
          the index alone lets us skip over the unwanted rows. (Again, MySQL
          can’t do this yet.)</p><div class="figure"><a id="a_loose_index_scan_which_mysql_cannot_cu"></a><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject4_d1e15268"></a><img src="/api/v2/epubs/9780596101718/files/httpatomoreillycomsourceoreillyimages206414.png" alt="A loose index scan, which MySQL cannot currently do, would be more efficient" width="467" height="767"></div></div><p class="title">Figure 4-6. A loose index scan, which MySQL cannot currently do, would
            be more efficient</p></div><p>This is admittedly a simplistic example, and we could easily
          optimize the query we’ve shown by adding a different index. However,
          there are many cases where adding another index can’t solve the
          problem. One example is a query that has a range condition on the
          index’s first column and an equality condition on the second
          column.<a id="idx-CHP-4-0772" class="indexterm"></a></p><p>Beginning in MySQL 5.0, loose index scans are possible in
          certain limited circumstances, such as queries that find maximum and
          minimum values in a grouped query:</p><a id="I_programlisting4_d1e15285"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT actor_id, MAX(film_id)</code></strong>
    -&gt; <strong class="userinput"><code>FROM sakila.film_actor</code></strong>
    -&gt; <strong class="userinput"><code>GROUP BY actor_id\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film_actor
         type: range
possible_keys: NULL
          key: PRIMARY
      key_len: 2
          ref: NULL
         rows: 396
        Extra: <strong class="userinput"><code>Using index for group-by</code></strong></pre><p>The “Using index for group-by” information in this <code class="literal">EXPLAIN</code> plan indicates a loose index scan.
          This is a good optimization for this special purpose, but it is not
          a general-purpose loose index scan. It might be better termed a
          “loose index probe.”</p><p>Until MySQL supports general-purpose loose index scans, the
          workaround is to supply a constant or list <a id="idx-CHP-4-0773" class="indexterm"></a>of constants for the leading columns of the index. We
          showed several examples <a id="idx-CHP-4-0774" class="indexterm"></a>of how to get good performance <a id="idx-CHP-4-0775" class="indexterm"></a>with these types of queries in our indexing case study
          in the previous chapter.</p></div><div class="sect3" title="MIN() and MAX()"><div class="titlepage"><div><div><h3 class="title"><a id="min_and_max"></a>MIN() and MAX()</h3></div></div></div><p>MySQL doesn’t optimize certain <code class="literal">MIN()</code> and <code class="literal">MAX()</code> queries very well. Here’s an
          example:<a id="idx-CHP-4-0776" class="indexterm"></a><a id="idx-CHP-4-0777" class="indexterm"></a></p><a id="I_programlisting4_d1e15344"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT MIN(actor_id) FROM sakila.actor WHERE first_name = 'PENELOPE';</code></strong></pre><p>Because there’s no index on <code class="literal">first_name</code>, this query performs a table
          scan. If MySQL scans the primary key, it can theoretically stop
          after reading the first matching row, because the primary key is
          strictly ascending and any subsequent row will have a greater
          <code class="literal">actor_id</code>. However, in this case,
          MySQL will scan the whole table, which you can verify by profiling
          the query. The workaround is to remove the <code class="literal">MIN()</code> and rewrite the query <a id="idx-CHP-4-0778" class="indexterm"></a>with a <code class="literal">LIMIT</code>, as
          follows:</p><a id="I_programlisting4_d1e15368"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT actor_id FROM sakila.actor USE INDEX(PRIMARY)</code></strong>
    -&gt; <strong class="userinput"><code>WHERE first_name = 'PENELOPE' LIMIT 1;</code></strong></pre><p>This general strategy often works well when MySQL would
          otherwise choose to scan more rows than necessary. If you’re a
          purist, you might object that this query is missing the point of
          SQL. We’re supposed to be able to tell the server
          <span class="emphasis"><em>what</em></span> we want and it’s supposed to figure out
          <span class="emphasis"><em>how</em></span> to get that data, whereas, in this case,
          we’re telling MySQL <span class="emphasis"><em>how</em></span> to execute the query
          and, as a result, it’s not clear from the query that
          <span class="emphasis"><em>what</em></span> we’re looking for is a minimal value.
          True, but sometimes you have to compromise your principles to get
          high performance.</p></div><div class="sect3" title="SELECT and UPDATE on the same table"><div class="titlepage"><div><div><h3 class="title"><a id="select_and_update_on_the_same_table"></a>SELECT and UPDATE on the same table</h3></div></div></div><p>MySQL doesn’t let you <code class="literal">SELECT</code> from a table while simultaneously
          running an <code class="literal">UPDATE</code> on it. This
          isn’t really an <a id="idx-CHP-4-0779" class="indexterm"></a>optimizer limitation, but knowing how MySQL executes
          queries can help you work around it. Here’s an example of a query
          that’s disallowed, even though it is standard SQL. The query updates
          each row with the number of similar rows in the table:</p><a id="I_programlisting4_d1e15408"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE tbl AS outer_tbl</code></strong>
    -&gt; <strong class="userinput"><code>   SET cnt = (</code></strong>
    -&gt; <strong class="userinput"><code>      SELECT count(*) FROM tbl AS inner_tbl</code></strong>
    -&gt; <strong class="userinput"><code>      WHERE inner_tbl.type = outer_tbl.type</code></strong>
    -&gt; <strong class="userinput"><code>   );</code></strong>
ERROR 1093 (HY000): You can't specify target table 'outer_tbl' for update in FROM
clause </pre><p>To work around this limitation, you can use a derived table,
          because MySQL materializes it as a temporary table. This effectively
          executes two queries: one <code class="literal">SELECT</code>
          inside the subquery, and one multitable <code class="literal">UPDATE</code> with the joined results of the
          table and the subquery. The subquery opens and closes the table
          before the outer <code class="literal">UPDATE</code> opens the
          table, so the query will now succeed:</p><a id="I_programlisting4_d1e15436"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE tbl</code></strong>
    -&gt; <strong class="userinput"><code>   INNER JOIN(</code></strong>
    -&gt; <strong class="userinput"><code>      SELECT type, <a id="idx-CHP-4-0780" class="indexterm"></a>count(*) AS cnt</code></strong>
    -&gt; <strong class="userinput"><code>      FROM tbl</code></strong>
    -&gt; <strong class="userinput"><code>      GROUP BY type</code></strong>
    -&gt; <strong class="userinput"><code>   ) AS der USING(type)</code></strong>
    -&gt; <strong class="userinput"><code>SET tbl.cnt = der.cnt;</code></strong></pre></div></div></div><div class="sect1" title="Optimizing Specific Types of Queries"><div class="titlepage"><div><div><h1 class="title"><a id="optimizing_specific_types_of_queries"></a>Optimizing Specific Types of Queries</h1></div></div></div><p>In this section, we give advice on how to optimize certain kinds
      of queries. We’ve covered most of these topics in detail elsewhere in
      the book, but we wanted to make a list of common optimization problems
      that you can refer to easily.</p><p>Most of the advice in this section is version-dependent, and it
      may not hold for future versions of MySQL. There’s no reason why the
      server won’t be able to do some or all of these <a id="idx-CHP-4-0781" class="indexterm"></a>optimizations itself someday.</p><div class="sect2" title="Optimizing COUNT() Queries"><div class="titlepage"><div><div><h2 class="title"><a id="optimizing_count_queries"></a>Optimizing COUNT() Queries</h2></div></div></div><p>The <code class="literal">COUNT()</code> aggregate
        function and how to optimize queries that use it is probably one of
        the top 10 most misunderstood topics in MySQL. You can do a web search
        and find more misinformation on this topic than we care to think
        about.</p><p>Before we get into optimization, it’s important that you
        understand what <code class="literal">COUNT()</code> really
        does.</p><div class="sect3" title="What COUNT() does"><div class="titlepage"><div><div><h3 class="title"><a id="what_count_does"></a>What COUNT() does</h3></div></div></div><p><code class="literal">COUNT()</code> is a special
          function that works in two very different ways: it counts
          <span class="emphasis"><em>values</em></span> and <span class="emphasis"><em>rows</em></span>. A value
          is a non-<code class="literal">NULL</code> expression
          (<code class="literal">NULL</code> is the absence of a value).
          If you specify a column name or other expression inside the
          parentheses, <code class="literal">COUNT()</code> counts how
          many times that expression has a value. This is confusing for many
          people, in part because values and <code class="literal">NULL</code> are confusing. If you need to learn
          how this works in SQL, we suggest a good book on SQL fundamentals.
          (The Internet is not necessarily a good source of accurate
          information on this topic, either.)</p><p>The other form of <code class="literal">COUNT()</code>
          simply counts the number of rows in the result. This is what MySQL
          does when it knows the expression inside the parentheses can never
          be <code class="literal">NULL</code>. The most obvious example
          is <code class="literal">COUNT(*)</code>, which is a special
          form of <code class="literal">COUNT()</code> that does not
          expand the * wildcard into the full list of columns in the table, as
          you might expect; instead, it ignores columns altogether and counts
          rows.</p><p>One of the most common mistakes we see is specifying column
          names inside the parentheses when you want to count rows. When you
          want to know the number of rows in the result, you should
          <span class="emphasis"><em>always</em></span> use <code class="literal">COUNT(*)</code>. This communicates your intention
          clearly and avoids poor performance.</p></div><div class="sect3" title="Myths about MyISAM"><div class="titlepage"><div><div><h3 class="title"><a id="myths_about_myisam"></a>Myths about MyISAM</h3></div></div></div><p>A common misconception is that MyISAM is extremely fast for
          <code class="literal">COUNT()</code> queries. It is fast, but
          only for a very special case: <code class="literal">COUNT(*)</code> without a <code class="literal">WHERE</code> clause, which merely counts the
          number of rows in the entire table. MySQL can optimize this away
          because the storage engine always knows how many rows are in the
          table. If MySQL knows <code class="literal">col</code> can
          never be <code class="literal">NULL</code>, it can also
          optimize a <code class="literal">COUNT(col)</code> expression
          by converting it to <code class="literal">COUNT(*)</code>
          internally.</p><p>MyISAM does not have any magical speed <a id="idx-CHP-4-0782" class="indexterm"></a>optimizations for counting rows when the query has a
          <code class="literal">WHERE</code> clause, or for the more
          general case of counting values instead of rows. It may be faster
          than other storage engines for a given query, or it may not be. That
          depends on a lot of factors.</p></div><div class="sect3" title="Simple optimizations"><div class="titlepage"><div><div><h3 class="title"><a id="simple_optimizations"></a>Simple optimizations</h3></div></div></div><p>You can sometimes use MyISAM’s <code class="literal">COUNT(*)</code> optimization to your advantage
          when you want to count all but a very small number of rows that are
          well indexed. The following example uses the standard World database
          to show how you can efficiently find the number of cities whose
          <code class="literal">ID</code> is greater than <code class="literal">5</code>. You might write this query as
          follows:</p><a id="I_programlisting4_d1e15589"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT COUNT(*) FROM world.City WHERE ID &gt; 5;</code></strong></pre><p>If you profile this query with <code class="literal">SHOW
          STATUS</code>, you’ll see that it scans 4,079 rows. If you negate
          the conditions and subtract the number of cities whose <code class="literal">ID</code>s are less than or equal to <code class="literal">5</code> from the total number of cities, you can
          reduce that to five rows:</p><a id="I_programlisting4_d1e15604"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT (SELECT COUNT(*) FROM world.City) - COUNT(*)</code></strong>
    -&gt; <strong class="userinput"><code>FROM world.City WHERE ID &lt;= 5;</code></strong></pre><p>This version reads fewer rows because the subquery is turned
          into a constant during the query optimization phase, as you can see
          with <code class="literal">EXPLAIN</code>:</p><a id="I_programlisting4_d1e15616"></a><pre class="programlisting">+----+-------------+-------+...+------+------------------------------+
| id | select_type | table |...| rows | Extra                        |
+----+-------------+-------+...+------+------------------------------+
|  1 | PRIMARY     | City  |...|    6 | Using where; Using index     |
|  2 | SUBQUERY    | NULL  |...| NULL | Select tables optimized away |
+----+-------------+-------+...+------+------------------------------+</pre><p>A frequent question on mailing lists and IRC channels is how
          to retrieve counts for several different values in the same column
          with just one query, to reduce the number of queries required. For
          example, say you want to create a single query that counts how many
          items have each of several colors. You can’t use an <code class="literal">OR</code> (e.g., <code class="literal">SELECT
          COUNT(color = 'blue' OR color = 'red') FROM items;</code>),
          because that won’t separate the different counts for the different
          colors. And you can’t put the colors in the <code class="literal">WHERE</code> clause (e.g., <code class="literal">SELECT COUNT(*) FROM items WHERE color = 'blue' AND
          color = 'red';</code>), because the colors are mutually
          exclusive. Here is a query that solves this problem:</p><a id="I_programlisting4_d1e15632"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT SUM(IF(color = 'blue', 1, 0)) AS blue,</code></strong>
<strong class="userinput"><code>SUM(IF(color = 'red', 1, 0))</code></strong>
-&gt; <strong class="userinput"><code>AS red FROM items;</code></strong></pre><p>And here is another that’s equivalent, but instead of using
          <code class="literal">SUM()</code> uses <code class="literal">COUNT()</code> and ensures that the expressions
          won’t have values when the criteria are false:</p><a id="I_programlisting4_d1e15650"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT COUNT(color = 'blue' OR NULL) AS blue, COUNT(color = 'red' OR NULL)</code></strong>
    -&gt; <strong class="userinput"><code>AS red FROM items;</code></strong></pre></div><div class="sect3" title="More complex optimizations"><div class="titlepage"><div><div><h3 class="title"><a id="more_complex_optimizations"></a>More complex optimizations</h3></div></div></div><p>In general, <code class="literal">COUNT()</code> queries
          are hard to optimize because they usually need to count a lot of
          rows (i.e., access a lot of data). Your only other option for
          optimizing within MySQL itself is to use a covering index, which we
          discussed in <a class="xref" href="ch03.html" title="Chapter 3. Schema Optimization and Indexing">Chapter 3</a>. If
          that doesn’t help enough, you need to make changes to your
          application architecture. Consider summary tables (also covered in
          <a class="xref" href="ch03.html" title="Chapter 3. Schema Optimization and Indexing">Chapter 3</a>), and possibly
          an external caching system such as <span class="emphasis"><em>memcached</em></span>.
          You’ll probably find yourself faced with the familiar dilemma,
          “fast, accurate, and simple: pick any two.”<a id="idx-CHP-4-0783" class="indexterm"></a></p></div></div><div class="sect2" title="Optimizing JOIN Queries"><div class="titlepage"><div><div><h2 class="title"><a id="optimizing_join_queries"></a>Optimizing JOIN Queries</h2></div></div></div><p>This topic is actually spread throughout most of the book, but
        we mention a few highlights:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Make sure there are indexes on the columns in the <code class="literal">ON</code> or <code class="literal">USING</code> clauses. See “Indexing Basics” on
            <a class="xref" href="ch03.html#indexing_basics" title="Indexing Basics">Indexing Basics</a> for more about indexing.
            Consider the join order when adding indexes. If you’re joining
            tables <code class="literal">A</code> and <code class="literal">B</code> on column <code class="literal">c</code> and the query optimizer decides to
            join the tables in the order <code class="literal">B,
            A</code>, you don’t need to index the column on table <code class="literal">B</code>. Unused indexes are extra overhead. In
            general, you need to add indexes only on the second table in the
            join order, unless they’re needed for some other reason.</p></li><li class="listitem"><p>Try to ensure that any <code class="literal">GROUP</code> <code class="literal">BY</code> or <code class="literal">ORDER
            BY</code> expression refers only to columns from a single
            table, so MySQL can try to use an index for that operation.</p></li><li class="listitem"><p>Be careful when upgrading MySQL, because the join syntax,
            operator precedence, and other behaviors have changed at various
            times. What used to be a normal join can sometimes become a cross
            product, a different kind of join that returns different results,
            or even invalid syntax.</p></li></ul></div></div><div class="sect2" title="Optimizing Subqueries"><div class="titlepage"><div><div><h2 class="title"><a id="optimizing_subqueries"></a>Optimizing Subqueries</h2></div></div></div><p>The most important advice we can give on subqueries is that you
        should usually prefer a join where possible, at least in current
        versions of MySQL. We covered this topic extensively earlier in this
        chapter.<a id="idx-CHP-4-0784" class="indexterm"></a></p><p>Subqueries are the subject of intense work by the optimizer
        team, and upcoming versions of MySQL may have more subquery <a id="idx-CHP-4-0785" class="indexterm"></a>optimizations. It remains to be seen which of the
        optimizations we’ve seen will end up in released code, and how much
        difference they’ll make. Our point here is that “prefer a join” is not
        future-proof advice. The server is getting smarter all the time, and
        the cases where you have to tell it how to do something instead of
        what results to return are becoming fewer.</p></div><div class="sect2" title="Optimizing GROUP BY and DISTINCT"><div class="titlepage"><div><div><h2 class="title"><a id="optimizing_group_by_and_distinct"></a>Optimizing GROUP BY and DISTINCT</h2></div></div></div><p>MySQL optimizes these two kinds of queries similarly in many
        cases, and in fact converts between them as needed internally during
        the optimization process. Both types of queries benefit from indexes,
        as usual, and that’s the single most important way to optimize
        them.<a id="idx-CHP-4-0786" class="indexterm"></a><a id="idx-CHP-4-0787" class="indexterm"></a></p><p>MySQL has two kinds of <code class="literal">GROUP</code>
        <code class="literal">BY</code> strategies when it can’t use an
        index: it can use a temporary table or a filesort to perform the
        grouping. Either one can be more efficient for any given query. You
        can force the optimizer to choose one method or the other with the
        <code class="literal">SQL_BIG_RESULT</code> and <code class="literal">SQL_SMALL_RESULT</code> optimizer hints.</p><p>If you need to group a join by a value that comes from a lookup
        table, it’s usually more efficient to group by the lookup table’s
        identifier than by the value. For example, the following query isn’t
        as efficient as it could be:</p><a id="I_programlisting4_d1e15770"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT actor.first_name, actor.last_name, COUNT(*)</code></strong>
    -&gt; <strong class="userinput"><code>FROM sakila.film_actor</code></strong>
    -&gt; <strong class="userinput"><code>   INNER JOIN sakila.actor USING(actor_id)</code></strong>
    -&gt; <strong class="userinput"><code>GROUP BY actor.first_name, actor.last_name;</code></strong></pre><p>The query is more efficiently written as follows:</p><a id="I_programlisting4_d1e15785"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT actor.first_name, actor.last_name, COUNT(*)</code></strong>
    -&gt; <strong class="userinput"><code>FROM sakila.film_actor</code></strong>
    -&gt; <strong class="userinput"><code>   INNER JOIN sakila.actor USING(actor_id)</code></strong>
    -&gt; <strong class="userinput"><code>GROUP BY film_actor.actor_id;</code></strong></pre><p>Grouping by <code class="literal">actor.actor_id</code>
        could be more efficient than grouping by <code class="literal">film_actor.actor_id</code>. You should profile
        and/or benchmark on your specific data to see.</p><p>This query takes advantage of the fact that the actor’s first
        and last name are dependent on the <code class="literal">actor_id</code>, so it will return the same
        results, but it’s not always the case that you can blithely select
        nongrouped columns and get the same result. You may even have the
        server’s <code class="literal">SQL_MODE</code> configured to
        disallow it. You can use <code class="literal">MIN()</code> or
        <code class="literal">MAX()</code> to work around this when you
        know the values within the group are <a id="idx-CHP-4-0788" class="indexterm"></a>distinct because they depend on the grouped-by column,
        or if you don’t care which value you get:</p><a id="I_programlisting4_d1e15826"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT MIN(actor.first_name), MAX(actor.last_name), ...;</code></strong></pre><p>Purists will argue that you’re grouping by the wrong thing, and
        they’re right. A spurious <code class="literal">MIN()</code> or
        <code class="literal">MAX()</code> is a sign that the query
        isn’t structured correctly. However, sometimes your only concern will
        be making MySQL execute the query as quickly as possible. The purists
        will be satisfied with the following way of writing the query:</p><a id="I_programlisting4_d1e15839"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT actor.first_name, actor.last_name, c.cnt</code></strong>
    -&gt; <strong class="userinput"><code>FROM sakila.actor</code></strong>
    -&gt; <strong class="userinput"><code>   INNER JOIN (</code></strong>
    -&gt; <strong class="userinput"><code>      SELECT actor_id, COUNT(*) AS cnt</code></strong>
    -&gt; <strong class="userinput"><code>      FROM sakila.film_actor</code></strong>
    -&gt; <strong class="userinput"><code>      GROUP BY actor_id</code></strong>
    -&gt; <strong class="userinput"><code>   ) AS c USING(actor_id) ;</code></strong></pre><p>But sometimes the cost of creating and filling the temporary
        table required <a id="idx-CHP-4-0789" class="indexterm"></a>for the subquery is high compared to the cost of fudging
        pure relational theory a little bit. Remember, the temporary table
        created by the subquery has no indexes.</p><p>It’s generally a bad idea to select nongrouped columns in a
        grouped query, because the results will be nondeterministic and could
        easily change if you change an index or the optimizer decides to use a
        different strategy. Most such queries we see are accidents (because
        the server doesn’t complain), or are the result of laziness rather
        than being designed that way for optimization purposes. It’s better to
        be explicit. In fact, we suggest that you set the server’s <code class="literal">SQL_MODE</code> configuration variable to include
        <code class="literal">ONLY_FULL_GROUP_BY</code> so it produces
        an error instead of letting you write a bad query.</p><p>MySQL automatically orders grouped queries by the columns in the
        <code class="literal">GROUP BY</code> clause, unless you specify
        an <code class="literal">ORDER BY</code> clause explicitly. If
        you don’t care about the order and you see this causing a filesort,
        you can use <code class="literal">ORDER BY NULL</code> to skip
        the automatic sort. You can also add an optional <code class="literal">DESC</code> or <code class="literal">ASC</code> keyword right after the <code class="literal">GROUP BY</code> clause to order the results in the
        desired direction by the clause’s columns.</p><div class="sect3" title="Optimizing GROUP BY WITH ROLLUP"><div class="titlepage"><div><div><h3 class="title"><a id="optimizing_group_by_with_rollup"></a>Optimizing GROUP BY WITH ROLLUP</h3></div></div></div><p>A variation on grouped queries is to ask MySQL to do
          superaggregation within the results. You can do this with a <code class="literal">WITH ROLLUP</code> clause, but it might not be as
          well optimized as you need. Check the execution method with <code class="literal">EXPLAIN</code>, paying attention to whether the
          grouping is done via filesort or temporary table; try removing the
          <code class="literal">WITH</code> <code class="literal">ROLLUP</code> and seeing if you get the same
          group method. You may be able to force the grouping method with the
          hints we mentioned earlier in this section.<a id="idx-CHP-4-0790" class="indexterm"></a></p><p>Sometimes it’s more efficient to do superaggregation in your
          application, even if it means fetching many more rows from the
          server. You can also nest a subquery in the <code class="literal">FROM</code> clause or use a temporary table to
          hold intermediate results.</p><p>The best approach may be to move the <code class="literal">WITH</code> <code class="literal">ROLLUP</code> functionality into your application
          code.</p></div></div><div class="sect2" title="Optimizing LIMIT and OFFSET"><div class="titlepage"><div><div><h2 class="title"><a id="optimizing_limit_and_offset"></a>Optimizing LIMIT and OFFSET</h2></div></div></div><p>Queries with <code class="literal">LIMIT</code>s and
        <code class="literal">OFFSET</code>s are common in systems that
        do pagination, nearly always in conjunction with an <code class="literal">ORDER BY</code> clause. It’s helpful to have an
        index that supports the ordering; otherwise, the server has to do a
        lot of filesorts.<a id="idx-CHP-4-0791" class="indexterm"></a><a id="idx-CHP-4-0792" class="indexterm"></a></p><p>A frequent problem is having a high value <a id="idx-CHP-4-0793" class="indexterm"></a>for the offset. If your query looks like <code class="literal">LIMIT 10000, 20</code>, it is generating 10,020
        rows and throwing away the first 10,000 of them, which is very
        expensive. Assuming all pages are accessed with equal frequency, such
        queries scan half the table on average. To optimize them, you can
        either limit how many pages are permitted in a pagination view, or try
        to make the high offsets more efficient.</p><p>One simple technique to improve efficiency is to do the offset
        on a covering index, rather than the full rows. You can then join the
        result to the full row and retrieve the additional columns you need.
        This can be much more efficient. Consider the following query:</p><a id="I_programlisting4_d1e15965"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT film_id, description FROM sakila.film ORDER BY title LIMIT 50, 5;</code></strong></pre><p>If the table is very large, this query is better written as
        follows:</p><a id="I_programlisting4_d1e15971"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT film.film_id, film.description</code></strong>
    -&gt; <strong class="userinput"><code>FROM sakila.film</code></strong>
    -&gt; <strong class="userinput"><code>   INNER JOIN (</code></strong>
    -&gt; <strong class="userinput"><code>      SELECT film_id FROM sakila.film</code></strong>
    -&gt; <strong class="userinput"><code>      ORDER BY title LIMIT 50, 5</code></strong>
    -&gt; <strong class="userinput"><code>   ) AS lim USING(film_id);</code></strong></pre><p>This works because it lets the server examine as little data as
        possible in an index without accessing rows, and then, once the
        desired rows are found, join them against the full table to retrieve
        the other columns from the row. A similar technique applies to joins
        with <code class="literal">LIMIT</code> clauses.</p><p>Sometimes you can also convert the limit to a positional query,
        which the server can execute as an index range scan. For example, if
        you precalculate and index a position column, you can rewrite the
        query as follows:</p><a id="I_programlisting4_d1e15998"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT film_id, description FROM sakila.film</code></strong>
    -&gt; <strong class="userinput"><code>WHERE position BETWEEN 50 AND 54 ORDER BY position;</code></strong></pre><p>Ranked data poses a similar problem, but usually mixes <code class="literal">GROUP BY</code> into the fray. You’ll almost
        certainly need to precompute and store ranks.</p><p>If you really need to optimize pagination systems, you should
        probably use precomputed summaries. As an alternative, you can join
        against redundant tables that contain only the primary key and the
        columns you need for the <code class="literal">ORDER BY</code>.
        You can also use Sphinx; see <a class="xref" href="apc.html" title="Appendix C. Using Sphinx with MySQL">Appendix C</a> for more information.</p></div><div class="sect2" title="Optimizing SQL_CALC_FOUND_ROWS"><div class="titlepage"><div><div><h2 class="title"><a id="optimizing_sql_calc_found_rows"></a>Optimizing SQL_CALC_FOUND_ROWS</h2></div></div></div><p>Another common technique for paginated displays is to add the
        <code class="literal">SQL_CALC_FOUND_ROWS</code> <a id="idx-CHP-4-0794" class="indexterm"></a>hint to a query with a <code class="literal">LIMIT</code>, so you’ll know how many rows would
        have been returned without the <code class="literal">LIMIT</code>. It may seem that there’s some kind of
        “magic” happening here, whereby the server predicts how many rows it
        would have found. But unfortunately, the server doesn’t really do
        that; it can’t count rows it doesn’t actually find. This option just
        tells the server to generate and throw away the rest of the result
        set, instead of stopping when it reaches the desired number of rows.
        That’s very expensive.<a id="idx-CHP-4-0795" class="indexterm"></a></p><p>A better design is to convert the pager to a “next” link.
        Assuming there are 20 results per page, the query should then use a
        <code class="literal">LIMIT</code> of 21 rows and display only
        20. If the 21st row exists in the results, there’s a next page, and
        you can render the “next” link.</p><p>Another possibility is to fetch and cache many more rows than
        you need—say, 1,000—and then retrieve them from the cache for
        successive pages. This strategy lets your application know how large
        the full result set is. If it’s fewer than 1,000 rows, the application
        knows how many page links to render; if it’s more, the application can
        just display “more than 1,000 results found.” Both strategies are much
        more efficient than repeatedly generating an entire result and
        discarding most of it.</p><p>Even when you can’t use these tactics, using a separate <code class="literal">COUNT(*)</code> query to find the number of rows
        can be much faster than <code class="literal">SQL_CALC_FOUND_ROWS</code>, if it can use a
        covering index.</p></div><div class="sect2" title="Optimizing UNION"><div class="titlepage"><div><div><h2 class="title"><a id="optimizing_union"></a>Optimizing UNION</h2></div></div></div><p>MySQL always executes <code class="literal">UNION</code>
        queries by creating a temporary table and filling it with the <code class="literal">UNION</code> results. MySQL can’t apply as many
        <a id="idx-CHP-4-0796" class="indexterm"></a>optimizations to <code class="literal">UNION</code> queries as you might be used to. You
        might have to help the optimizer by manually “pushing down” <code class="literal">WHERE, LIMIT, ORDER BY</code>, and other conditions
        (i.e., copying them, as appropriate, from the outer query into each
        <code class="literal">SELECT</code> in the <code class="literal">UNION</code>).<a id="idx-CHP-4-0797" class="indexterm"></a></p><p>It’s important to <span class="emphasis"><em>always</em></span> use <code class="literal">UNION ALL</code>, unless you need the server to
        eliminate duplicate rows. If you omit the <code class="literal">ALL</code> keyword, MySQL adds the <code class="literal">distinct</code> option to the temporary table,
        which uses the full row to determine uniqueness. This is quite
        expensive. Be aware that the <code class="literal">ALL</code>
        keyword doesn’t eliminate the temporary table, though. MySQL always
        places results into a temporary table and then reads them out again,
        even when it’s not really necessary (for example, when the results
        could be returned directly to the client).<a id="I_indexterm4_d1e16109" class="indexterm"></a></p></div></div><div class="sect1" title="Query Optimizer Hints"><div class="titlepage"><div><div><h1 class="title"><a id="query_optimizer_hints"></a>Query Optimizer Hints</h1></div></div></div><p>MySQL has a few <a id="idx-CHP-4-0798" class="indexterm"></a>optimizer <a id="idx-CHP-4-0799" class="indexterm"></a>hints you can use to control the query plan if you’re not
      happy with the one MySQL’s optimizer chooses. The following list
      identifies these hints and indicates when it’s a good idea to use them.
      You place the appropriate hint in the query whose plan you want to
      modify, and it is effective for only that query. Check the MySQL manual
      for the exact syntax of each hint. Some of them are version-dependent.
      The options are:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">HIGH_PRIORITY</code>
          <span class="emphasis"><em>and</em></span> <code class="literal">LOW_PRIORITY</code></span></dt><dd><p>These hints tell MySQL how to prioritize the statement
            relative to other statements that are trying to access the same
            tables.<a id="idx-CHP-4-0800" class="indexterm"></a><a id="idx-CHP-4-0801" class="indexterm"></a></p><p><code class="literal">HIGH_PRIORITY</code> tells MySQL
            to schedule a <code class="literal">SELECT</code> statement
            before other statements that may be waiting for locks, so they can
            modify data. In effect, it makes the <code class="literal">SELECT</code> go to the front of the queue
            instead of waiting its turn. You can also apply this modifier to
            <code class="literal">INSERT</code>, where it simply cancels
            the effect of a global <code class="literal">LOW_PRIORITY</code> server setting.</p><p><code class="literal">LOW_PRIORITY</code> is the
            reverse: it makes the statement wait at the very end of the queue
            if there are any other statements that want to access the
            tables—even if the other statements are issued after it. It’s
            rather like an overly polite person holding the door at a
            restaurant: as long as there’s anyone else waiting, it will starve
            itself! You can apply this hint to <code class="literal">SELECT, INSERT, UPDATE, REPLACE</code>, and
            <code class="literal">DELETE</code> statements.</p><p>These hints are effective on storage engines with
            table-level locking, but you should never need them on InnoDB or
            other engines with fine-grained locking and concurrency control.
            Be careful when using them on MyISAM, because they can disable
            concurrent inserts and greatly reduce performance.</p><p>The <code class="literal">HIGH_PRIORITY</code> and
            <code class="literal">LOW_PRIORITY</code> hints are a
            frequent source of confusion. They do not allocate more or fewer
            resources to queries to make them “work harder” or “not work as
            hard”; they simply affect how the server queues statements that
            are waiting for access to a table.</p></dd><dt><span class="term"><code class="literal">DELAYED</code></span></dt><dd><p>This hint is for use with <code class="literal">INSERT</code> and <code class="literal">REPLACE</code>. It lets the statement to which
            it is applied return immediately and places the inserted rows into
            a buffer, which will be inserted in bulk when the table is free.
            This is most useful for logging and similar applications where you
            want to insert a lot of rows without making the client wait, and
            without causing I/O for each statement. There are many
            limitations; for example, delayed inserts are not implemented in
            all storage engines, and <code class="literal">LAST_INSERT_ID()</code> doesn’t work with
            them.<a id="idx-CHP-4-0802" class="indexterm"></a></p></dd><dt><span class="term"><code class="literal">STRAIGHT_JOIN</code></span></dt><dd><p>This hint can appear either just after the <code class="literal">SELECT</code> keyword in a <code class="literal">SELECT</code> statement, or in any statement
            between two joined tables. The first usage forces all tables in
            the query to be joined in the order in which they’re listed in the
            statement. The second usage forces a join order on the two tables
            between which the hint appears.<a id="idx-CHP-4-0803" class="indexterm"></a></p><p>The <code class="literal">STRAIGHT_JOIN</code> hint is
            useful when MySQL doesn’t choose a good join order, or when the
            optimizer takes a long time to decide on a join order. In the
            latter case, the thread will spend a lot of time in “Statistics”
            state, and adding this hint will reduce the search space for the
            optimizer.</p><p>You can use <code class="literal">EXPLAIN</code> to
            see what order the optimizer would choose, then rewrite the query
            in that order and add <code class="literal">STRAIGHT_JOIN</code>. This is a good idea as
            long as you don’t think the fixed order will result in bad
            performance for some <code class="literal">WHERE</code>
            clauses. You should be careful to revisit such queries after
            upgrading MySQL, however, because new optimizations may appear
            that will be defeated by <code class="literal">STRAIGHT_JOIN</code>.</p></dd><dt><span class="term"><code class="literal">SQL_SMALL_RESULT</code>
          <span class="emphasis"><em>and</em></span> <code class="literal">SQL_BIG_RESULT</code></span></dt><dd><p>These hints are for <code class="literal">SELECT</code> statements. They tell the
            optimizer how and when to use temporary tables and sort in
            <code class="literal">GROUP BY</code> or <code class="literal">DISTINCT</code> queries. <code class="literal">SQL_SMALL_RESULT</code> tells the optimizer
            that the result set will be small and can be put into indexed
            temporary tables to avoid sorting for the grouping, whereas
            <code class="literal">SQL_BIG_RESULT</code> indicates that
            the result will be large and that it will be better to use
            temporary tables on disk with sorting.<a id="idx-CHP-4-0804" class="indexterm"></a><a id="idx-CHP-4-0805" class="indexterm"></a></p></dd><dt><span class="term"><code class="literal">SQL_BUFFER_RESULT</code></span></dt><dd><p>This hint tells the optimizer to put the results into a
            temporary table and release table locks as soon as possible. This
            is different from the client-side buffering we described in “The
            MySQL Client/Server Protocol” on <a class="xref" href="ch04.html#query_execution_basics" title="Query Execution Basics">Query Execution Basics</a>. Server-side buffering can be
            useful when you don’t use buffering on the client, as it lets you
            avoid consuming a lot of memory on the client and still release
            locks quickly. The tradeoff is that the server’s memory is used
            instead of the client’s.<a id="idx-CHP-4-0806" class="indexterm"></a></p></dd><dt><span class="term"><code class="literal">SQL_CACHE</code>
          <span class="emphasis"><em>and</em></span> <code class="literal">SQL_NO_CACHE</code></span></dt><dd><p>These hints instruct the server that the query either is or
            is not a candidate for caching in the query cache. See the next
            chapter for details on how to use them.<a id="idx-CHP-4-0807" class="indexterm"></a><a id="idx-CHP-4-0808" class="indexterm"></a></p></dd><dt><span class="term"><code class="literal">SQL_CALC_FOUND_ROWS</code></span></dt><dd><p>This hint tells MySQL to calculate a full result set when
            there’s a <code class="literal">LIMIT</code> clause, even
            though it returns only <code class="literal">LIMIT</code>
            rows. You can retrieve the total number of rows it found via
            <code class="literal">FOUND_ROWS()</code> (but see
            “Optimizing SQL_CALC_FOUND_ROWS” on <a class="xref" href="ch04.html#optimizing_union" title="Optimizing UNION">Optimizing UNION</a> for reasons why you shouldn’t use
            this hint).</p></dd><dt><span class="term"><code class="literal">FOR UPDATE</code>
          <span class="emphasis"><em>and</em></span> <code class="literal">LOCK IN SHARE
          MODE</code></span></dt><dd><p>These hints control locking for <code class="literal">SELECT</code> statements, but only for storage
            engines that have row-level locks. They enable you to place locks
            on the matched rows, which can be useful when you want to lock
            rows you know you are going to update later, or when you want to
            avoid lock escalation and just acquire exclusive locks as soon as
            possible.<a id="idx-CHP-4-0809" class="indexterm"></a><a id="idx-CHP-4-0810" class="indexterm"></a></p><p>These hints are not needed for <code class="literal">INSERT … SELECT</code> queries, which place
            read locks on the source rows by default in MySQL 5.0. (You can
            disable this behavior, but it’s not a good idea—we explain why in
            Chapters <a class="xref" href="ch08.html" title="Chapter 8. Replication">Chapter 8</a> and <a class="xref" href="ch11.html" title="Chapter 11. Backup and Recovery">Chapter 11</a>.) MySQL 5.1 may lift this
            restriction under certain conditions.</p><p>At the time of this writing, only InnoDB supports these
            hints, and it’s too early to say whether other storage engines
            with row-level locks will support them in the future. When using
            these hints with InnoDB, be aware that they may disable some
            optimizations, such as covering indexes. InnoDB can’t lock rows
            exclusively without accessing the primary key, which is where the
            row versioning information is stored.</p></dd><dt><span class="term"><code class="literal">USE INDEX, IGNORE INDEX</code>,
          <span class="emphasis"><em>and</em></span> <code class="literal">FORCE
          INDEX</code></span></dt><dd><p>These hints tell the optimizer which indexes to use or
            ignore for finding rows in a table (for example, when deciding on
            a join order). In MySQL 5.0 and earlier, they don’t influence
            which indexes the server uses for sorting and grouping; in MySQL
            5.1 the syntax can take an optional <code class="literal">FOR
            ORDER BY</code> or <code class="literal">FOR GROUP
            BY</code> clause.<a id="idx-CHP-4-0811" class="indexterm"></a><a id="idx-CHP-4-0812" class="indexterm"></a><a id="idx-CHP-4-0813" class="indexterm"></a></p><p><code class="literal">FORCE INDEX</code> is the same
            as <code class="literal">USE INDEX</code>, but it tells the
            optimizer that a table scan is extremely expensive compared to the
            index, even if the index is not very useful. You can use these
            hints when you don’t think the optimizer is choosing the right
            index, or when you want to take advantage of an index for some
            reason, such as implicit ordering without an <code class="literal">ORDER BY</code>. We gave an example of this in
            “Optimizing LIMIT and OFFSET” on <a class="xref" href="ch04.html#optimizing_sql_calc_found_rows" title="Optimizing SQL_CALC_FOUND_ROWS">Optimizing SQL_CALC_FOUND_ROWS</a>, where we showed how
            to get a minimum value efficiently with <code class="literal">LIMIT</code>.</p></dd></dl></div><p>In MySQL 5.0 and newer, there are also some <a id="idx-CHP-4-0814" class="indexterm"></a>system variables that influence the optimizer:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">optimizer_search_depth</code></span></dt><dd><p>This variable tells the optimizer how exhaustively to
            examine partial plans. If your queries are taking a very long time
            in the “Statistics” state, you might try lowering this
            value.<a id="idx-CHP-4-0815" class="indexterm"></a></p></dd><dt><span class="term"><code class="literal">optimizer_prune_level</code></span></dt><dd><p>This variable, which is enabled by default, lets the
            optimizer skip certain plans based on the number of rows
            examined.<a id="idx-CHP-4-0816" class="indexterm"></a></p></dd></dl></div><p>Both options control optimizer shortcuts. These shortcuts are
      valuable for good performance on complex queries, but they can cause the
      server to miss optimal plans for the sake of efficiency. That’s why it
      sometimes makes sense to change them.</p></div><div class="sect1" title="User-Defined Variables"><div class="titlepage"><div><div><h1 class="title"><a id="user-defined_variables"></a>User-Defined Variables</h1></div></div></div><p>It’s easy to forget about MySQL’s <a id="idx-CHP-4-0817" class="indexterm"></a>user-defined variables, but they can be a powerful
      technique for writing efficient queries. They work especially well for
      queries that benefit from a mixture of procedural and relational logic.
      Purely relational queries treat everything as unordered sets that the
      server somehow manipulates all at once. MySQL takes a more pragmatic
      approach. This can be a weakness, but it can be a strength if you know
      how to exploit it, and user-defined <a id="idx-CHP-4-0818" class="indexterm"></a>variables can help.</p><p>User-defined variables are temporary containers for values, which
      persist as long as your connection to the server lives. You define them
      by simply assigning to them with a <code class="literal">SET</code> or <code class="literal">SELECT</code> statement: <sup>[<a id="CHP-4-FNOTE-13" href="#ftn.CHP-4-FNOTE-13" class="footnote">48</a>]</sup></p><a id="I_programlisting4_d1e16463"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @one       := 1;</code></strong>
mysql&gt; <strong class="userinput"><code>SET @min_actor := (SELECT MIN(actor_id) FROM sakila.actor);</code></strong>
mysql&gt; <strong class="userinput"><code>SET @last_week := CURRENT_DATE-INTERVAL 1 WEEK;</code></strong></pre><p>You can then use the variables in most places an expression can
      go:</p><a id="I_programlisting4_d1e16475"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT ... WHERE col &lt;= @last_week;</code></strong></pre><p>Before we get into the strengths of user-defined variables, let’s
      take a look at some of their peculiarities and disadvantages and see
      what things you <span class="emphasis"><em>can’t</em></span> use them for:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>They prevent query caching.</p></li><li class="listitem"><p>You can’t use them where a literal or identifier is needed,
          such as for a table or column name, or in the <code class="literal">LIMIT</code> clause.</p></li><li class="listitem"><p>They are connection-specific, so you can’t use them for
          interconnection communication.</p></li><li class="listitem"><p>If you’re using connection pooling or persistent connections,
          they can cause seemingly isolated parts of your code to
          interact.</p></li><li class="listitem"><p>They are case sensitive in MySQL versions prior to 5.0, so
          beware of compatibility issues.</p></li><li class="listitem"><p>You can’t explicitly declare these variables’ types, and the
          point at which types are decided for undefined variables differs
          across MySQL versions. The best thing to do is initially assign a
          value of <code class="literal">0</code> for variables you want
          to use for integers, <code class="literal">0.0</code> for
          floating-point numbers, or '' (the empty string) for strings. A
          variable’s type changes when it is assigned to; MySQL’s user-defined
          variable typing is dynamic.</p></li><li class="listitem"><p>The optimizer might optimize away these variables in some
          situations, preventing them from doing what you want.</p></li><li class="listitem"><p>Order of assignment, and indeed even the time of assignment,
          can be nondeterministic and depend on the query plan the optimizer
          chose. The results can be very confusing, as you’ll see
          later.</p></li><li class="listitem"><p>The <code class="literal">:=</code> assignment operator
          has lower precedence than any other operator, so you have to be
          careful to parenthesize explicitly.</p></li><li class="listitem"><p>Undefined <a id="idx-CHP-4-0819" class="indexterm"></a>variables do not generate a syntax error, so it’s easy
          to make mistakes without knowing it.</p></li></ul></div><p>One of the most important features of <a id="idx-CHP-4-0820" class="indexterm"></a>variables is that you can assign a value to a variable and
      use the resulting value at the same time. In other words, an assignment
      is an <span class="emphasis"><em>L-value</em></span>. Here’s an example that
      simultaneously calculates and outputs a “row number” for a query:</p><a id="I_programlisting4_d1e16540"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @rownum := 0;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT actor_id, @rownum := @rownum + 1 AS rownum</code></strong>
    -&gt; <strong class="userinput"><code>FROM sakila.actor LIMIT 3;</code></strong>
+----------+--------+
| actor_id | rownum |
+----------+--------+
|        1 |      1 |
|        2 |      2 |
|        3 |      3 |
+----------+--------+</pre><p>This example isn’t terribly interesting, because it just shows
      that we can duplicate the table’s primary key. Still, it has its
      uses—one of which is ranking. Let’s write a query that returns the 10
      actors who have played in the most movies, with a rank column that gives
      actors the same rank if they’re tied. We start with a query that finds
      the actors and the number of movies:</p><a id="I_programlisting4_d1e16554"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT actor_id, COUNT(*) as cnt</code></strong>
    -&gt; <strong class="userinput"><code>FROM sakila.film_actor</code></strong>
    -&gt; <strong class="userinput"><code>GROUP BY actor_id</code></strong>
    -&gt; <strong class="userinput"><code>ORDER BY cnt DESC</code></strong>
    -&gt; <strong class="userinput"><code>LIMIT 10;</code></strong>
+----------+-----+
| actor_id | cnt |
+----------+-----+
|      107 |  42 |
|      102 |  41 |
|      198 |  40 |
|      181 |  39 |
|       23 |  37 |
|       81 |  36 |
|      106 |  35 |
|       60 |  35 |
|       13 |  35 |
|      158 |  35 |
+----------+-----+</pre><p>Now let’s add the rank, which should be the same for all the
      actors who played in 35 movies. We use three <a id="idx-CHP-4-0821" class="indexterm"></a>variables to do this: one to keep track of the current
      rank, one to keep track of the previous actor’s movie count, and one to
      keep track of the current actor’s movie count. We change the rank when
      the movie count changes. Here’s a first try:</p><a id="I_programlisting4_d1e16577"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @curr_cnt := 0, @prev_cnt := 0, @rank := 0;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT actor_id,</code></strong>
    -&gt; <strong class="userinput"><code>   @curr_cnt := COUNT(*) AS cnt,</code></strong>
    -&gt; <strong class="userinput"><code>   @rank     := IF(@prev_cnt &lt;&gt; @curr_cnt, @rank + 1, @rank) AS rank,</code></strong>
    -&gt; <strong class="userinput"><code>   @prev_cnt := @curr_cnt AS dummy</code></strong>
    -&gt; <strong class="userinput"><code>FROM sakila.film_actor</code></strong>
    -&gt; <strong class="userinput"><code>GROUP BY actor_id</code></strong>
    -&gt; <strong class="userinput"><code>ORDER BY cnt DESC</code></strong>
    -&gt; <strong class="userinput"><code>LIMIT 10;</code></strong>
+----------+-----+------+-------+
| actor_id | cnt | rank | dummy |
+----------+-----+------+-------+
|      107 |  42 |    0 |     0 |
|      102 |  41 |    0 |     0 |
...</pre><p>Oops—the rank and count never got updated from zero. Why did this
      happen?</p><p>It’s impossible to give a one-size-fits-all answer. The problem
      could be as simple as a misspelled variable name (in this example it’s
      not), or something more involved. In this case, <code class="literal">EXPLAIN</code> shows there’s a temporary table and
      filesort, so the variables are being evaluated at a different time from
      when we expected.</p><p>This is the type of inscrutable behavior you’ll often experience
      with MySQL’s <a id="idx-CHP-4-0822" class="indexterm"></a>user-defined variables. Debugging such problems can be
      tough, but it can really pay off. Ranking in SQL normally requires
      quadratic algorithms, such as counting the distinct number of actors who
      played in a greater number of movies. A user-defined variable solution
      can be a linear algorithm—quite an improvement.</p><p>An easy solution in this case is to add another level of temporary
      tables to the query, using a subquery in the <code class="literal">FROM</code> clause:</p><a id="I_programlisting4_d1e16625"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @curr_cnt := 0, @prev_cnt := 0, @rank := 0;</code></strong>
    -&gt; <strong class="userinput"><code>SELECT actor_id,</code></strong>
    -&gt; <strong class="userinput"><code>   @curr_cnt := cnt AS cnt,</code></strong>
    -&gt; <strong class="userinput"><code>   @rank     := IF(@prev_cnt &lt;&gt; @curr_cnt, @rank + 1, @rank) AS rank,</code></strong>
    -&gt; <strong class="userinput"><code>   @prev_cnt := @curr_cnt AS dummy</code></strong>
    -&gt; <strong class="userinput"><code>FROM (</code></strong>
    -&gt; <strong class="userinput"><code>   SELECT actor_id, COUNT(*) AS cnt</code></strong>
    -&gt; <strong class="userinput"><code>   FROM sakila.film_actor</code></strong>
    -&gt; <strong class="userinput"><code>   GROUP BY actor_id</code></strong>
    -&gt; <strong class="userinput"><code>   ORDER BY cnt DESC</code></strong>
    -&gt; <strong class="userinput"><code>   LIMIT 10</code></strong>
    -&gt; <strong class="userinput"><code>) as der;</code></strong>
+----------+-----+------+-------+
| actor_id | cnt | rank | dummy |
+----------+-----+------+-------+
|      107 |  42 |    1 |    42 |
|      102 |  41 |    2 |    41 |
|      198 |  40 |    3 |    40 |
|      181 |  39 |    4 |    39 |
|       23 |  37 |    5 |    37 |
|       81 |  36 |    6 |    36 |
|      106 |  35 |    7 |    35 |
|       60 |  35 |    7 |    35 |
|       13 |  35 |    7 |    35 |
|      158 |  35 |    7 |    35 |
+----------+-----+------+-------+</pre><p>Most problems with user <a id="idx-CHP-4-0823" class="indexterm"></a>variables come from assigning to them and reading them at
      different stages in the query. For example, it doesn’t work predictably
      to assign them in the <code class="literal">SELECT</code>
      statement and read from them in the <code class="literal">WHERE</code> clause. The following query might look
      like it will just return one row, but it doesn’t:</p><a id="I_programlisting4_d1e16677"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @rownum := 0;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT actor_id, @rownum := @rownum + 1 AS cnt</code></strong>
    -&gt; <strong class="userinput"><code>FROM sakila.actor</code></strong>
    -&gt; <strong class="userinput"><code>WHERE @rownum &lt;= 1;</code></strong>
+----------+------+
| actor_id | cnt  |
+----------+------+
|        1 |    1 |
|        2 |    2 |
+----------+------+</pre><p>This happens because the <code class="literal">WHERE</code>
      and <code class="literal">SELECT</code> are different stages in
      the query execution process. This is even more obvious when you add
      another stage to execution with an <code class="literal">ORDER
      BY</code>:</p><a id="I_programlisting4_d1e16703"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @rownum := 0;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT actor_id, @rownum := @rownum + 1 AS cnt</code></strong>
    -&gt; <strong class="userinput"><code>FROM sakila.actor</code></strong>
    -&gt; <strong class="userinput"><code>WHERE @rownum &lt;= 1</code></strong>
    -&gt; <strong class="userinput"><code>ORDER BY first_name;</code></strong></pre><p>This query returns every row in the table, because the <code class="literal">ORDER BY</code> added a filesort and the <code class="literal">WHERE</code> is evaluated before the filesort. The
      solution to this problem is to assign and read in the
      <span class="emphasis"><em>same</em></span> stage of query execution:</p><a id="I_programlisting4_d1e16730"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @rownum := 0;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT actor_id, @rownum AS rownum</code></strong>
    -&gt; <strong class="userinput"><code>FROM sakila.actor</code></strong>
    -&gt; <strong class="userinput"><code>WHERE (@rownum := @rownum + 1) &lt;= 1;</code></strong>
+----------+--------+
| actor_id | rownum |
+----------+--------+
|        1 | 1      |
+----------+--------+</pre><p>Pop quiz: what will happen if you add the <code class="literal">ORDER BY</code> back to this query? Try it and see.
      If you didn’t get the results you expected, why not? What about the
      following query, where the <code class="literal">ORDER BY</code>
      changes the variable’s value and the <code class="literal">WHERE</code> clause evaluates it?</p><a id="I_programlisting4_d1e16755"></a><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET @rownum := 0;</code></strong>
mysql&gt; <strong class="userinput"><code>SELECT actor_id, first_name, @rownum AS rownum</code></strong>
    -&gt; <strong class="userinput"><code>FROM sakila.actor</code></strong>
    -&gt; <strong class="userinput"><code>WHERE @rownum &lt;= 1</code></strong>
    -&gt; <strong class="userinput"><code>ORDER BY first_name, LEAST(0, @rownum := @rownum + 1);</code></strong></pre><p>The answer to most unexpected user-defined variable behavior can
      be found by running <code class="literal">EXPLAIN</code> and
      looking for “Using where,” “Using temporary,” or “Using filesort” in the
      <code class="literal">Extra</code> column.</p><p>The last example introduced another useful hack: we placed the
      assignment in the <code class="literal">LEAST()</code> function,
      so its value is effectively masked and won’t skew the results of the
      <code class="literal">ORDER BY</code> (as we’ve written it, the
      <code class="literal">LEAST()</code> function will always return
      <code class="literal">0</code>). This trick is very helpful when
      you want to do variable assignments solely for their side effects: it
      lets you hide the return value and avoid extra columns, such as the
      <code class="literal">dummy</code> column we showed in a previous
      example. The <code class="literal">GREATEST(), LENGTH(), ISNULL(),
      NULLIF(), COALESCE(),</code> and <code class="literal">IF()</code> functions are also useful for this
      purpose, alone and in combination, because they have special behaviors.
      For instance, <code class="literal">COALESCE()</code> stops
      evaluating its arguments as soon as one has a defined value.</p><p>You can put variable assignments in all types of statements, not
      just <code class="literal">SELECT</code> statements. In fact, this
      is one of the best uses for <a id="idx-CHP-4-0824" class="indexterm"></a>user-defined variables. For example, you can rewrite
      expensive queries, such as rank calculations with subqueries, as cheap
      once-through <code class="literal">UPDATE</code>
      statements.</p><p>It can be a little tricky to get the desired behavior, though.
      Sometimes the optimizer decides to consider the <a id="idx-CHP-4-0825" class="indexterm"></a>variables compile-time constants and refuses to perform
      assignments. Placing the assignments inside a function like <code class="literal">LEAST()</code> will usually help. Another tip is to
      check whether your variable has a defined value before executing the
      containing statement. Sometimes you want it to, but other times you
      don’t.</p><p>With a little experimentation, you can do all sorts of interesting
      things with user-defined variables. Here are some ideas:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Calculate running totals and averages</p></li><li class="listitem"><p>Emulate <code class="literal">FIRST()</code> and
          <code class="literal">LAST()</code> functions for grouped
          queries</p></li><li class="listitem"><p>Do math on extremely large numbers</p></li><li class="listitem"><p>Reduce an entire table to a single MD5 hash value</p></li><li class="listitem"><p>“Unwrap” a sampled value that wraps when it increases beyond a
          certain boundary</p></li><li class="listitem"><p>Emulate read/write cursors<a id="I_indexterm4_d1e16854" class="indexterm"></a></p></li></ul></div><div class="sect2" title="Be Careful with MySQL Upgrades"><div class="titlepage"><div><div><h2 class="title"><a id="be_careful_with_mysql_upgrades"></a>Be Careful with MySQL Upgrades</h2></div></div></div><p>As we’ve said, trying to outsmart the MySQL optimizer usually is
        not a good idea. It generally creates more work and increases
        maintenance costs for very little benefit. This is especially relevant
        when you upgrade MySQL, because optimizer hints used in your queries
        might prevent new optimizer strategies from being used.</p><p>The way the MySQL optimizer uses indexes is a moving target. New
        MySQL versions change how existing indexes can be used, and you should
        adjust your indexing practices as these new versions become available.
        For example, we’ve mentioned that MySQL 4.0 and older could use only
        one index per table per query, but MySQL 5.0 and newer can use index
        merge strategies.</p><p>Besides the big changes MySQL occasionally makes to the query
        optimizer, each incremental release typically includes many tiny
        changes. These changes usually affect small things, such as the
        conditions under which an index is excluded from consideration, and
        let MySQL optimize more special cases.</p><p>Although all this sounds good in theory, in practice some
        queries perform <span class="emphasis"><em>worse</em></span> after an upgrade. If you’ve
        used a certain version for a long time, you have likely tuned certain
        queries just for that version, whether you know it or not. These
        optimizations may no longer apply in newer versions, or may degrade
        performance.</p><p>If you care about high performance you should have a benchmark
        suite that represents your particular workload, which you can run
        against the new version on a development server before you upgrade the
        production servers. Also, before upgrading, you should read the
        release notes and the list of known bugs in the new version. The MySQL
        manual includes a user-friendly list of known serious bugs.</p><p>Most MySQL upgrades bring better performance overall; we don’t
        mean to imply otherwise. However, you should still be careful.</p></div></div><div class="footnotes"><br><hr><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-1" href="#CHP-4-FNOTE-1" class="para">36</a>] </sup>Network overhead is worst if the application is on a
            different host from the server, but transferring data between
            MySQL and the application isn’t free even if they’re on the same
            server.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-2" href="#CHP-4-FNOTE-2" class="para">37</a>] </sup>See “Optimizing COUNT() Queries” on <a class="xref" href="ch04.html#optimizing_specific_types_of_queries" title="Optimizing Specific Types of Queries">Optimizing Specific Types of Queries</a> for more on
              this topic.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-3" href="#CHP-4-FNOTE-3" class="para">38</a>] </sup>Maatkit’s <span class="emphasis"><em>mk-archiver</em></span> tool makes these
            types of jobs easy.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-4" href="#CHP-4-FNOTE-4" class="para">39</a>] </sup>If the query is too large, the server will refuse to receive
            any more data and throw an error.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-5" href="#CHP-4-FNOTE-5" class="para">40</a>] </sup>You can work around this with <code class="literal">SQL_BUFFER_RESULT</code>, which we see a bit
            later.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-6" href="#CHP-4-FNOTE-6" class="para">41</a>] </sup>For example, the range check query plan reevaluates
              indexes for each row in a <code class="literal">JOIN</code>. You can see this query plan by
              looking for “range checked for each record” in the <code class="literal">Extra</code> column in <code class="literal">EXPLAIN</code>. This query plan also
              increments the <code class="literal">Select_full_range_join</code> server
              variable.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-7" href="#CHP-4-FNOTE-7" class="para">42</a>] </sup>We agree, a movie without actors is strange, but the
                    Sakila sample database lists no actors for “SLACKER
                    LIAISONS,” which it describes as “A Fast-Paced Tale of a
                    Shark And a Student who must Meet a Crocodile in Ancient
                    China.”</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-8" href="#CHP-4-FNOTE-8" class="para">43</a>] </sup>As we show later, MySQL’s query <a id="idx-CHP-4-0716" class="indexterm"></a>execution isn’t quite this simple; there are many
              optimizations that complicate it.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-9" href="#CHP-4-FNOTE-9" class="para">44</a>] </sup>There are no indexes on the temporary table, which is
              something you should keep in mind when writing complex joins
              against subqueries in the <code class="literal">FROM</code> clause. This applies to <code class="literal">UNION</code> queries, too.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-10" href="#CHP-4-FNOTE-10" class="para">45</a>] </sup>The server generates the output from the execution plan.
              It thus has the same semantics as the original query, but not
              necessarily the same text.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-11" href="#CHP-4-FNOTE-11" class="para">46</a>] </sup>Strictly speaking, MySQL doesn’t try to reduce the number
              of rows it reads. Instead, it tries to optimize <a id="idx-CHP-4-0730" class="indexterm"></a>for fewer page reads. But a row count can often
              give you a rough idea of the query cost.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-12" href="#CHP-4-FNOTE-12" class="para">47</a>] </sup>You can influence this behavior if needed—for example, with
            the <code class="literal">SQL_BUFFER_RESULT</code> hint. See
            the “Query Optimizer Hints” on <a class="xref" href="ch04.html#optimizing_union" title="Optimizing UNION">Optimizing UNION</a>, later in this chapter.</p></div><div class="footnote"><p><sup>[<a id="ftn.CHP-4-FNOTE-13" href="#CHP-4-FNOTE-13" class="para">48</a>] </sup>In some contexts you can assign with a plain = sign, but we
          think it’s better to avoid ambiguity and always use :=.</p></div></div></div></div>
    </div>
    
    <section class="t-bottom-cta bottom-cta bottom-cta-book free-chapter">
  <p>Get <em>High Performance MySQL, 2nd Edition</em> now with the O’Reilly <span class="nowrap">learning platform.</span></p>
  <p>O’Reilly members experience books, live events, courses curated by job role, and more from O’Reilly and <span class="nowrap">nearly 200 top publishers.</span></p>

  <div class="controls">
      <a href="https://learning.oreilly.com/p/register/" class="button-primary" data-ga-label="Bottom CTA">Start your free trial</a>
  </div>
</section>

</div>


</section>



  </div>
</main>


  <footer id="footer" class="footer">
  <div class="content">
    <div class="footer-main" aria-label="company info">
      <div class="footer-mainLeft">
        <div class="footer-mainLeftOne">
          <div class="footer-approach">
            <h2 class="footer-header"><a href="https://www.oreilly.com/about/">About O’Reilly</a></h2>
            <ul class="footer-links">
              <li><a href="https://www.oreilly.com/work-with-us.html">Teach/write/train</a></li>
              <li><a href="https://www.oreilly.com/careers/">Careers</a></li>
              <li><a href="https://www.oreilly.com/press/">Press releases</a></li>
              <li><a href="https://www.oreilly.com/press/media-coverage.html">Media coverage</a></li>
              <li><a href="https://www.oreilly.com/partner/signup.csp">Community partners</a></li>
              <li><a href="https://www.oreilly.com/affiliates/">Affiliate program</a></li>
              <li><a href="https://www.oreilly.com/online-learning/rfp.html">Submit an RFP</a></li>
              <li><a href="https://www.oreilly.com/diversity/">Diversity</a></li>
              <li><a href="https://www.oreilly.com/content-marketing-solutions.html" id="footerSponsorshipLink">O’Reilly for marketers</a></li>
            </ul>
          </div>
        </div>
        <div class="footer-mainLeftTwo">
          <div class="footer-contact">
            <h2 class="footer-header"><a href="https://www.oreilly.com/online-learning/support/">Support</a></h2>

            <ul class="footer-links">
              <li><a href="https://www.oreilly.com/about/contact.html">Contact us</a></li>
              <li><a href="https://www.oreilly.com/emails/newsletters/">Newsletters</a></li>
              <li><a href="https://www.oreilly.com/privacy.html">Privacy policy</a></li>
            </ul>
          
            <a href="https://twitter.com/oreillymedia" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 400 400" style="enable-background:new 0 0 400 400;" xml:space="preserve"><style type="text/css">.st0{fill:#ee0000;}.st1{fill:#FFFFFF;}</style><g id="Red"><circle class="st0" cx="200" cy="200" r="200"/></g><g id="Logo__x2014__FIXED"><path class="st1" d="M163.4,305.5c88.7,0,137.2-73.5,137.2-137.2c0-2.1,0-4.2-0.1-6.2c9.4-6.8,17.6-15.3,24.1-25 c-8.6,3.8-17.9,6.4-27.7,7.6c10-6,17.6-15.4,21.2-26.7c-9.3,5.5-19.6,9.5-30.6,11.7c-8.8-9.4-21.3-15.2-35.2-15.2 c-26.6,0-48.2,21.6-48.2,48.2c0,3.8,0.4,7.5,1.3,11c-40.1-2-75.6-21.2-99.4-50.4c-4.1,7.1-6.5,15.4-6.5,24.2 c0,16.7,8.5,31.5,21.5,40.1c-7.9-0.2-15.3-2.4-21.8-6c0,0.2,0,0.4,0,0.6c0,23.4,16.6,42.8,38.7,47.3c-4,1.1-8.3,1.7-12.7,1.7 c-3.1,0-6.1-0.3-9.1-0.9c6.1,19.2,23.9,33.1,45,33.5c-16.5,12.9-37.3,20.6-59.9,20.6c-3.9,0-7.7-0.2-11.5-0.7 C110.8,297.5,136.2,305.5,163.4,305.5"/></g></svg></a>
            <a href="https://www.linkedin.com/company/oreilly-media" target="_blank"><svg data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32.25 32.25"><defs><style>.cls-1{fill:#E00;fill-rule:evenodd;}</style></defs><title>linkedin-logo</title><path class="cls-1" d="M17.43,13.53v0l0,0ZM16.12,0A16.13,16.13,0,1,0,32.25,16.12,16.12,16.12,0,0,0,16.12,0ZM11.77,22.92H8.12v-11h3.65ZM9.94,10.44h0a1.89,1.89,0,0,1-2-1.89A1.91,1.91,0,0,1,10,6.65a1.9,1.9,0,1,1,0,3.79Zm15,12.48H21.28V17.05c0-1.48-.53-2.49-1.85-2.49a2,2,0,0,0-1.88,1.34,2.63,2.63,0,0,0-.12.89v6.13H13.79s.05-10,0-11h3.64V13.5a3.63,3.63,0,0,1,3.29-1.82c2.4,0,4.21,1.57,4.21,4.95Z"/></svg></a>
            <a href="https://www.youtube.com/user/OreillyMedia" target="_blank"><svg data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32.25 32.25"><defs><style>.cls-1{fill:#E00;fill-rule:evenodd;}</style></defs><title>youtube-logo</title><path class="cls-1" d="M18.35,18.68a.89.89,0,0,0-.86.63V16.94h-1v7.59h1v-.59a.92.92,0,0,0,.89.74c.52,0,.86-.36,1-1.07a8.56,8.56,0,0,0,.14-1.9,10.47,10.47,0,0,0-.12-1.93C19.21,19.05,18.87,18.68,18.35,18.68Zm.09,4.14c-.05.52-.2.77-.45.77s-.43-.21-.49-.63a7.22,7.22,0,0,1,0-1c0-.72,0-1.14,0-1.26.07-.58.23-.88.51-.88s.4.27.46.79c0,.09,0,.47,0,1.13S18.46,22.71,18.44,22.82ZM8.61,18.19H9.86v6.34H11V18.19H12.2V16.94H8.61Zm7.71-6.12c.27,0,.43-.22.49-.66,0-.09,0-.45,0-1.07V9.78c0-.58,0-.93,0-1-.07-.43-.23-.65-.48-.65s-.41.19-.48.57a8.79,8.79,0,0,0,0,1v.53c0,.71,0,1.09,0,1.16C15.88,11.82,16.05,12.07,16.32,12.07Zm-1.74,10.4a2.92,2.92,0,0,1-.06.71c-.07.25-.2.37-.4.37s-.32-.11-.38-.34a2.63,2.63,0,0,1-.05-.66V18.83h-1v4.48c0,.91.33,1.37,1,1.37A1,1,0,0,0,14.6,24v.57h1v-5.7h-1Zm7.1-3.79a1.35,1.35,0,0,0-1.22.59,2.48,2.48,0,0,0-.3,1.07c0,.23,0,.61,0,1.16s0,1.13,0,1.37a2.93,2.93,0,0,0,.35,1.27,1.25,1.25,0,0,0,1.14.54,1.36,1.36,0,0,0,1.13-.45,2.29,2.29,0,0,0,.37-1.43s0-.07,0-.11v-.12h-1c0,.75-.17,1.12-.51,1.12s-.38-.18-.45-.56a4.68,4.68,0,0,1-.06-.9c0-.18,0-.31,0-.37h2v-.43a4.86,4.86,0,0,0-.3-2.11A1.28,1.28,0,0,0,21.68,18.68ZM22.15,21h-1c0-.05,0-.11,0-.16v-.08a1.64,1.64,0,0,1,.11-.8.39.39,0,0,1,.38-.23.42.42,0,0,1,.43.33,2.32,2.32,0,0,1,.07.7Zm-6-21A16.13,16.13,0,1,0,32.25,16.12,16.12,16.12,0,0,0,16.12,0Zm2.51,7.2h1V11a2.52,2.52,0,0,0,.06.66c.06.23.18.34.38.34s.34-.12.41-.37a3.76,3.76,0,0,0,.05-.71V7.2h1v5.74h-1v-.57a1,1,0,0,1-.93.72c-.66,0-1-.46-1-1.38ZM15,8a1.29,1.29,0,0,1,1.33-.92A1.3,1.3,0,0,1,17.65,8a6.77,6.77,0,0,1,.23,2.1,6.77,6.77,0,0,1-.23,2.1,1.3,1.3,0,0,1-1.32.92A1.29,1.29,0,0,1,15,12.17a6.77,6.77,0,0,1-.23-2.1A6.86,6.86,0,0,1,15,8ZM11.45,5.3l.89,2.87.88-2.87H14.4L12.88,9.7v3.24h-1.1V9.7L10.24,5.3ZM24.93,23.91a3,3,0,0,1-3,3h-12a3,3,0,0,1-3-3V18.05a3,3,0,0,1,3-3h12a3,3,0,0,1,3,3Z"/></svg></a>
          </div>

          <div class="footer-international">
            <h2 class="footer-header">International</h2>

            <ul class="footer-links">
              <li><a href="https://www.oreilly.com/anz/">Australia &amp; New Zealand</a></li>
              <li><a href="https://oreilly.hk/">Hong Kong &amp; Taiwan</a></li>
              <li><a href="https://oreillylearning.in/">India</a></li>
              <li><a href="https://oreilly.id/">Indonesia</a></li>
              <li><a href="https://www.oreilly.co.jp/index.shtml">Japan</a></li>
            </ul>
          </div>
        </div>
      </div>

      <div class="footer-download" id="download-info">
        <h2 class="footer-header">Download the O’Reilly App</h2>
        <p>Take O’Reilly with you and learn anywhere, anytime on your phone <span class="nowrap">and tablet.</span></p>

        <div class="footer-downloadLinks">
          <a href="https://itunes.apple.com/us/app/safari-to-go/id881697395"><img src="https://cdn.oreillystatic.com/oreilly/images/app-store-logo.png" alt="Apple app store" /></a>
          <a href="https://play.google.com/store/apps/details?id=com.safariflow.queue"><img src="https://cdn.oreillystatic.com/oreilly/images/google-play-logo.png"  alt="Google play store" /></a>
        </div>
      </div>

      <div class="footer-download" id="tv-info">
        <h2 class="footer-header">Watch on your big screen</h2>
        <p>View all O’Reilly videos, Superstream events, and Meet the Expert sessions on your <span class="nowrap">home TV.</span></p>

        <div class="footer-downloadLinks">
          <a href="https://channelstore.roku.com/details/c8a2d0096693eb9455f6ac165003ee06/oreilly"><img src="https://cdn.oreillystatic.com/oreilly/images/roku-tv-logo.png" alt="Roku Payers and TVs" /></a>
          <a href="https://www.amazon.com/OReilly-Media-Inc/dp/B087YYHL5C/ref=sr_1_2?dchild=1&keywords=oreilly&qid=1604964116&s=mobile-apps&sr=1-2"><img src="https://cdn.oreillystatic.com/oreilly/images/amazon-appstore-logo.png"  alt="Amazon appstore" /></a>
        </div>
      </div>

      <div class="footer-donotsell" id="donotsell-info">
        <h2 class="footer-header"><a href="https://www.oreilly.com/privacy.html?donotsell=show">Do not sell my personal information</a></h2>
      </div>
    </div>

    <div class="footer-subfooter">

      <a href="https://www.oreilly.com" title="home page" aria-current="page">
        <img 
        class="footer-subfooterLogo" 
        id="footer-subfooterLogo"
        src="https://cdn.oreillystatic.com/images/sitewide-headers/oreilly_logo_mark_red.svg" 
        onerror="this.src='https://cdn.oreillystatic.com/images/sitewide-headers/oreilly_logo_mark_red_@2x.png'; this.onerror=null;" 
        alt="O'Reilly home">
      </a>

      <p>&copy; 2023, O’Reilly Media, Inc. All trademarks and registered trademarks appearing on oreilly.com are the property of their respective owners.</p>
      
      

      <p><a href="https://www.oreilly.com/terms/">Terms of service</a> • <a href="https://www.oreilly.com/privacy.html">Privacy policy</a> • <a href="https://www.oreilly.com/about/editorial_independence.html">Editorial independence</a></p>
    </div>

  </div>
</footer>



  <div class="exitIntentOverlay" id="exitIntentOverlay">
    <div class="exitIntentOverlay-contents">
      <div class="exitIntentOverlay-columns">
        <div class="exitIntentOverlay-text">
          <h2>Don’t leave <span class="nowrap">empty-handed</span></h2>

          <p>Get Mark Richards’s <em>Software Architecture Patterns</em> ebook to better understand how to design components—and how they should interact.</p>

          <h3>It’s yours, free.</h3>

          <a class="exitIntentOverlay-cta" href="https://get.oreilly.com/ind_software-architecture-patterns.html">Get it now</a>
        </div>

        <figure class="exitIntentOverlay-figure"><img src="https://cdn.oreillystatic.com/oreilly/images/report-software-architecture-patterns-553x420.jpg" alt="Cover of Software Architecture Patterns"></figure>
      </div>

      <button class="exitIntentOverlay-close">Close</button>
    </div>
  </div>
  

  <div class="exitIntentOverlay2" id="exitIntentOverlay2">
    <div class="exitIntentOverlay-contents">
      <div class="exitIntentOverlay-columns">
        <div class="exitIntentOverlay-text">
          <h2>Check it out now <span class="nowrap">on O’Reilly</span></h2>

          <p>Dive in for free with a 10-day trial of the O’Reilly learning platform—then explore all the other resources our members count on to build skills and solve problems <span class="nowrap">every day.</span></p>

          <a id="exitIntentOverlay2StartYourFreeTrial" class="exitIntentOverlay-cta" href="https://www.oreilly.com/start-trial/">Start your free trial</a>

          <a class="exitIntentOverlay-cta" href="https://learning.oreilly.com/signup/">Become a member now</a>
        </div>

        <figure class="exitIntentOverlay-figure"><img src="https://cdn.oreillystatic.com/oreilly/images/laptop-flat-topics-ml-1124x638.png" alt=""></figure>
      </div>

      <button class="exitIntentOverlay-close">Close</button>
    </div>
  </div>






<script>
  var g = {
    
    position_cache: {},
    title: "High Performance MySQL, 2nd Edition",
    author_list: "Jeremy D. Zawodny, Derek J. Balling, Baron Schwartz, Peter Zaitsev, Arjen Lentz, Vadim Tkachenko",
    format: "book",
    source: "application/epub+zip",
    is_system_book: true,
    is_public: true,
    loaded_from_server: true,
    allow_scripts: false,
    has_mathml: false
    
  };
</script>
<script>
  window.dataLayer = window.dataLayer || [];
  window.dataLayer.push({
    'product.title': "High Performance MySQL, 2nd Edition",
    'product.type': "book",
    'product.identifier': "9780596101718",
    'content.identifier': "9780596101718/ch04.html",
    'content.publisher': "O'Reilly Media, Inc.",
    'content.free': "no",
    //
    'content.subdirectory': "none",
    'content.subTopic': "none",
    'content.parentTopic': "none",
    'content.formatType': "book-chapter",
    'content.author': "Jeremy D. Zawodny, Derek J. Balling, Baron Schwartz, Peter Zaitsev, Arjen Lentz, Vadim Tkachenko",
    'content.releaseDate': "2008-06-18",
    'content.title': "4. Query Performance Optimization",
  });
</script>

<script>
  // Datadog RUM integration to measure performance and Core Web Vitals
  // https://docs.datadoghq.com/real_user_monitoring/browser/#overview
  // https://web.dev/vitals/
  (function(h,o,u,n,d) {
    h=h[d]=h[d]||{q:[],onReady:function(c){h.q.push(c)}}
    d=o.createElement(u);d.async=1;d.src=n
    n=o.getElementsByTagName(u)[0];n.parentNode.insertBefore(d,n)
  })(window,document,'script','https://www.datadoghq-browser-agent.com/datadog-rum.js','DD_RUM')
  DD_RUM.onReady(function() {
    DD_RUM.init({
      clientToken: 'pub1221d36d3b6dfda5f3c3b7ed22e3b6af',
      applicationId: '291bce39-f950-4fc6-a610-10abfead0661',
      site: 'datadoghq.com',
      service:'anybird',
      env:'production',
      // Specify a version number to identify the deployed version of your application in Datadog 
      // version: '1.0.0',
      sampleRate: 10,
      trackInteractions: true,
    })
  })
</script>






<script src="/library/view/static/CACHE/js/output.59a09b1a350e.js"></script>


<noscript> 
  <iframe src="//www.googletagmanager.com/ns.html?id=GTM-5P4V6Z"
          height="0" width="0"
          style="display:none;visibility:hidden">
  </iframe>
</noscript>


<script async defer src="/library/view/pageview.js"></script>

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>

<script src="https://cdn.oreillystatic.com/assets/js/anybird/promotion.js"></script>


<script>
  //Exit intent overlay scripts

  //Setter and getter for exit intent cookie
  const ExitIntentCookieService = {
    setCookie(name, value, days) {
      let expires = '';
  
      if (days) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        expires = '; expires=' + date.toUTCString();
      }
  
      document.cookie = name + '=' + (value || '')  + expires + ';';
    },
  
    getCookie(name) {
      const cookies = document.cookie.split(';');
  
      for (const cookie of cookies) {
        if (cookie.indexOf(name + '=') > -1) {
          return cookie.split('=')[1];
        }
      }
  
      return null;
    }
  };
  
  //When a user clicks outside overlay or close icon or hits escape key
  //close exit intent overlay 
  const exit = e => {
    const shouldExit =
      [...e.target.classList].includes('exitIntentOverlay') || // user clicks on overlay
      [...e.target.classList].includes('exitIntentOverlay2') || // user clicks on overlay2
      e.target.className === 'exitIntentOverlay-close' || // user clicks on the close icon
      e.keyCode === 27; // user hits escape
  
    if (shouldExit) {
      document.querySelector('.exitIntentOverlay').classList.remove('visible');
      document.querySelector('.exitIntentOverlay2').classList.remove('visible');
    }
  };
  
  //When a user's cursor leaves the document
  //show exit intent overlay 
  const mouseEvent = e => {
    const shouldShowExitIntent = 
      !e.toElement && 
      !e.relatedTarget &&
      e.clientY < 10;
  
    if (shouldShowExitIntent) {
      document.removeEventListener('mouseout', mouseEvent);
      
      if (exitIntentCookieValue === null) {
        //Set value of exitIntentCookieValue
        exitIntentCookieValue = '1';

        //make exitIntentOverlay visible
        document.querySelector('.exitIntentOverlay').classList.add('visible');

        //Send tracking for exit intent overlay impression
        window.dataLayer.push({
          'event': 'eventTracker',
          'eventCat': 'marketing',
          'eventAct': 'exit intent imp',
          'eventLbl': 'modal 1'
        });
      } else if (exitIntentCookieValue === '1') {
        //Set value of exitIntentCookieValue
        exitIntentCookieValue = '2';

        //make exitIntentOverlay2 visible
        document.querySelector('.exitIntentOverlay2').classList.add('visible');
        
        //Send tracking for exit intent overlay impression
        window.dataLayer.push({
          'event': 'eventTracker',
          'eventCat': 'marketing',
          'eventAct': 'exit intent imp',
          'eventLbl': 'modal 2'
        });

        //Add click tracking for "start your free trial" button
        const StartYourFreeTrial = document.querySelector("#exitIntentOverlay2StartYourFreeTrial");
        StartYourFreeTrial.addEventListener('click', function(e) {
          window.dataLayer.push({
            'event': 'eventTracker',
            'eventCat': 'marketing',
            'eventAct': 'exit intent',
            'eventLbl': 'start your free trial'
          });
        });
      }

      //Set exit intent cookie
      ExitIntentCookieService.setCookie('libraryExitIntentShown', exitIntentCookieValue, 30);
    }
  };
  
  //If exit intentcookie doesn't exist,
  //then initialize exit intent overlay scripts
  var exitIntentCookieValue = ExitIntentCookieService.getCookie('libraryExitIntentShown');
  if (exitIntentCookieValue === null || exitIntentCookieValue === '1') {
    setTimeout(() => {
      document.addEventListener('mouseout', mouseEvent);
      document.addEventListener('keydown', exit);
      document.querySelector('.exitIntentOverlay').addEventListener('click', exit);
      document.querySelector('.exitIntentOverlay2').addEventListener('click', exit);
    }, 0);
  }
</script>


<script>
  jQuery(document).ready(function($) {
    //Toggle isActive and mobileHidden classes for mobileNavButton
    $('nav #mobileNavButton').on('click', function() {
      var expanded = $(this).attr('aria-expanded') === 'true' || false;
      $(this).attr('aria-expanded', !expanded);
      $(this).toggleClass("isActive");
      $(this).next().toggleClass("mobileHidden");
    });

    //Toggle isFocused class for keyboard navigation of submenus
    $('nav #menuList .menuList-subItem a').each(function(navItem) {
      $(this).on('focus', function() {
        $(this).parent().parent().toggleClass('isFocused');
      });
      $(this).on('blur', function() {
        $(this).parent().parent().toggleClass('isFocused');
      });
    });

    //Toggle mobileHidden class accordian elements
    $('.mobileAccordian').each(function() {
      var $btn = $(this).find('button');
      var $target =  $(this).next();
      $btn.on('click', function() {
        var expanded = $btn.attr('aria-expanded') === 'true' || false;

        $btn.attr('aria-expanded', !expanded);
        $target.toggleClass("mobileHidden");
      });
    });


    //Hide title page's long description behind disclosure button
    var titleDescriptionExtra = $('.title-description p:first-of-type').nextAll(':nth-child(3)').nextAll();
    titleDescriptionExtra.wrapAll('<div id="titleDescriptionExtra" />');
    if (titleDescriptionExtra.length > 0) {
      $('#titleDescriptionExtra').toggle();
      $('#showMoreDescription').removeClass('hidden');
      $('#showMoreDescription button').on('click', function() {
        $(this).toggleClass('more');
        $('#titleDescriptionExtra').slideToggle();
      });
    }

    //Hide title page's long TOC behind disclosure button
    var titleTOCShort = $('.sbo-reader-title .detail-toc').find('li').slice(0,4);
    var titleTOCExtra = $('.sbo-reader-title .detail-toc').find('li').not(titleTOCShort);
    if (titleTOCExtra.length > 0) {
      titleTOCExtra.toggle();
      $('#showMoreTOC').removeClass('hidden');
      $('#showMoreTOC button').on('click', function() {
        $(this).toggleClass('more');
        titleTOCExtra.toggle();
      });
    }

    //Hide product information on page load
    $('#product-information').toggle();
    $('#title-tabs button').on('click', function() {
      var $thisTab = $(this);
      if (!$thisTab.hasClass('title-tab-active')) {
        var lastTabTarget = $('#title-tabs .title-tab-active').removeClass('title-tab-active').attr('data-target');
        $('#' + lastTabTarget).toggle();

        $thisTab.addClass('title-tab-active');
        var $tabTarget = $(this).attr('data-target');
        $('#' + $tabTarget).toggle();
      }
    });

    // Append highlight fragment hash to sign in link for highlighting
    if (window.location.hash.indexOf('#:-:text') > -1) {
      // encode the hash symbol to prevent it from being used as a location hash by groot-fe
      var highlightFragment = window.location.hash.replace('#:-:text', '%23:-:text');
      $('#chapter-sign-in').attr('href', $('#chapter-sign-in').attr('href') + highlightFragment);
    }

    //Trigger GA events for related products
    $('#recommendations .recommendations-item').each(function(i) {
      $(this).on('click', function(e) {
        var cardTitle = $(this).find('.recommendations-title').text().toLowerCase();
        var productType = $(this).find('.recommendations-format').text().toLowerCase();
        var contentID = $(this).attr('data-id');
        var eventLbl = String(i);

        dataLayer.push({
          'product.title': undefined,
          'content.formatType': undefined,
          'product.identifier': undefined,
          'content.title': undefined,
          'content.author': undefined,
          'content.publisher': undefined,
          'content.releaseDate': undefined,
          'content.free': undefined,
          'content.subdirectory': undefined,
          'content.parentTopic': undefined,
          'content.subTopic': undefined,
          'event': 'eventTracker',
          'eventCat': 'recommended titles',
          'eventAct': 'card click',
          'eventLbl': eventLbl,
          'eventVal': 0, 
          'nonInteraction': 0,
          'cardTitle': cardTitle,
          'product.type': productType,
          'content.identifier': contentID,
          'eventCallback': function() {
            dataLayer.push({'cardTitle': undefined});
          },
          'eventTimeout' : 2000
        });
      });
    });

    //Trigger GA event for "Try Now" nav button
    $('.menuList-tryNow > a').on('click', function() {
      dataLayer.push({
        'event': 'eventTracker',
        'eventCat':'marketing',
        'eventAct':'nav',
        'eventLbl':'try now',
        'eventVal':0, 
        'nonInteraction': 0,
      });
    });

    //Trigger GA event for "Sign In" nav button
    $('.menuList-signIn > a').on('click', function() {
      dataLayer.push({
        'event': 'eventTracker',
        'eventCat':'marketing',
        'eventAct':'nav',
        'eventLbl':'sign in',
        'eventVal':0, 
        'nonInteraction': 0,
      });
    });

  });

</script>



<!-- MARC Intercept Support -->

<script src="https://service.seamlessaccess.org/thiss.js"></script>

<script src="/library/view/static/CACHE/js/output.f644e79d688c.js"></script>


</body>
</html>
